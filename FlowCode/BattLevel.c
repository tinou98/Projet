//************************************************************************************
//**  
//**  File name:     P:\SI\Projet\FlowCode\BattLevel.c
//**  Generated by:  Flowcode v4.5.18.74
//**  Date:          Friday, January 16, 2015 10:00:58
//**  Licence:       10 User
//**  Registered to: LYCEE-STMARC38-02
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL 
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Définir pour microcontrôleur
#define P18F4455
#define MX_EE
#define MX_EE_TYPE3
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_BCB
#define MX_SPI_SDI 0
#define MX_SPI_SDO 7
#define MX_SPI_SCK 1
#define MX_UART
#define MX_UART_C
#define MX_UART_TX 6
#define MX_UART_RX 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_B
#define MX_I2C_SDA 0
#define MX_I2C_SCL 1
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 2
#define MX_PWM_TRIS2 trisc
#define MX_PWM_2 1
#define MX_PWM_TRIS2a trisb
#define MX_PWM_2a 3
#define MX_USB_TYPE1

//Fonctions
#define MX_CLK_SPEED 48000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic18.h>
#endif

//Données de Configuration
#ifdef _BOOSTC
#pragma DATA 0x300000, 0x20
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0xe
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0x3e
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0x1e
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x81
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0x81
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0x80
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xa0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif

//Fonctions internes
#include "C:\Program Files\Matrix Multimedia\Flowcode V4\FCD\internals.h"

//Déclarations de fonction Macro
void FCM_initLed();
void FCM_showBattLevel();
char FCM_isBattLevelOK(char FCL_PRCT);
char FCM_getBat();
char FCM_getTrou(short FCL_TIMEOUT);


//Déclarations de Variable
char FCV_ISTROU;
char FCV_BATTLEVELOK;
char FCV_FALSE;
char FCV_TRUE;

char FCLV_LOOP1;
char FCLV_LOOP2;



//ADC(0): //Defines:

/**** Macro Substitutions ****
0 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
0 = VRef+ Option
500 = VRef Voltage x 0.01V
0 = MIAC System ordinal
0 = MIAC System module type
******************************/




//ADC(0): //Déclarations de fonction Macro

void FCD_ADC0_SampleADC();
char FCD_ADC0_ReadAsByte();
short FCD_ADC0_ReadAsInt();
float FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);


//PWM(0): //Defines:

/**** Macro Substitutions ****
255 = Timer 2 Rollover Value
0x04 = Timer 2 Prescaler Value
-1 = MIAC System ID
0 = Alternate Pin FCD_PWM0_Enable
******************************/




//PWM(0): //Déclarations de fonction Macro

void FCD_PWM0_Enable(char nIdx);
void FCD_PWM0_Disable(char nIdx);
void FCD_PWM0_SetDutyCycle(char nIdx, char nDuty);
void FCD_PWM0_ChangePeriod(char nPeriodVal, char nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(char nIdx, short nDuty);



//ADC(0): //Implémentations Macro


void FCD_ADC0_SampleADC()
{
	
	/*******Supported Devices******************************************************************
	// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
	// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
	// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
	// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
	// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
	// 18F4680, 18F4682, 18F4685
	******************************************************************************************/

	#ifndef MX_MIAC

		#define MX_ADC_CHANNEL		0
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		0

		//set up ADC conversion
		char old_tris, cnt;
		adcon2 = MX_ADC_CONV_SP & 0x07;

		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x0E;
		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x0D;
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x0C;
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x08
			adcon1 = 0x0B;
			#if (MX_ADC_VREF_OPT != 0)
				#error "Target device is currently using AN3 for VREF+"
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x20
			adcon1 = 0x0A;
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x09;
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x08;
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x07;
		#endif
		#if (MX_ADC_CHANNEL == 8)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x06;
		#endif
		#if (MX_ADC_CHANNEL == 9)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x05;
		#endif
		#if (MX_ADC_CHANNEL == 10)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x04;
		#endif
		#if (MX_ADC_CHANNEL == 11)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x03;
		#endif
		#if (MX_ADC_CHANNEL == 12)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x02;
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#error "ADC Type 13 conversion code error - please contact technical support"
		#endif

		//assign VREF functionality
		#if (MX_ADC_VREF_OPT != 0)
			st_bit(adcon1, VCFG0);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;

		//turn ADC on
		adcon0 = 0x01 | (MX_ADC_CHANNEL << 2);

		//wait the acquisition time
		cnt = 0;
		while (cnt < MX_ADC_SAMP_TIME) cnt++;

		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x02;
		while (adcon0 & 0x02);

		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
		adcon1 = 0x0f;
		adcon0 = 0x00;

		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CHANNEL
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

	#endif

}

char FCD_ADC0_ReadAsByte()
{
	
	#ifdef MX_MIAC_SYSTEM
		int iSample;

		iSample = FCD_ADC0_ReadAsInt();

		return (iSample >> 2);
	#else

		FCD_ADC0_SampleADC();

		return adresh;
	#endif

}

short FCD_ADC0_ReadAsInt()
{
	
		short iRetVal;

	#ifdef MX_MIAC_SYSTEM

	  #if (0 == MX_MIAC_MM_MIAC_BASE)
	  	iRetVal = MIAC_Master_InputANA10(0);
	  #else
		unsigned int ModID = ((0 << 5) + 0) << 9;

		MIAC_CAN_TX[0] = 0;

		MIAC_Module_WR(ModID, 289, 1,1,0);
		MIAC_Module_GetAck(ModID + 32, 289, 200);
		iRetVal = ((MIAC_CAN_RX[0] << 8) | MIAC_CAN_RX[1]) >> 2;
	  #endif
	#else
		FCD_ADC0_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);
	#endif
		return (iRetVal);

}

float FCD_ADC0_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC0_ReadAsInt();											//Read as 10-bit Integer

		fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
		fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
		fSample = float32_from_int32(iSample);							//Convert to floating point variable
		fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//PWM(0): //Implémentations Macro


void FCD_PWM0_Enable(char nIdx)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif

	#ifdef MX_MIAC_EXTERNAL
		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[1] = 255;
		MIAC_CAN_TX[2] = 0x04;
		MIAC_Module_WR(ModID, 320, 3, 1, 0);
		MIAC_Module_GetAck(ModID + 32, 320, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  #ifndef MX_PWM		//error checking
		#error "This chip does not have PWM capability"
	  #else
		#ifndef MX_PWM_CNT
			#error "FCD file error (no MX_PWM_CNT)"
		#endif
		#if (MX_PWM_CNT < 1)
			#error "FCD file error (MX_PWM_CNT < 1)"
		#endif
		//#if (MX_PWM_CNT > 2)
		//	#error "FCD file error (MX_PWM_CNT > 2)"
		//#endif
		#ifndef MX_PWM_TRIS1
			#error "FCD file error (no MX_PWM_TRIS1)"
		#endif
		#ifndef MX_PWM_1
			#error "FCD file error (no MX_PWM_1)"
		#endif
	    #if (MX_PWM_CNT == 2)
	      	#ifndef MX_PWM_TRIS2
				#error "FCD file error (no MX_PWM_TRIS2)"
	      	#endif
	      	#ifndef MX_PWM_2
				#error "FCD file error (no MX_PWM_2)"
	      	#endif
	    #endif
	    #if (0 == 1)
	      	#ifndef MX_PWM_TRIS1a
				#error "PWM component error (using alternative, but no MX_PWM_TRIS1a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	      	#ifndef MX_PWM_1a
				#error "PWM component error (using alternative, but no MX_PWM_1a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	    #endif
	    #if (0 == 2)
	      	#ifndef MX_PWM_TRIS2a
				#error "PWM component error (using alternative, but no MX_PWM_TRIS2a)"
	  			#define MX_PWM_ALT_ERROR
	      	#endif
	      	#ifndef MX_PWM_2a
				#error "PWM component error (using alternative, but no MX_PWM_2a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	    #endif

	 	#ifdef MX_PWM
			pr2 = 255;
			t2con = 0x04;
		#endif

	  	#if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccp1con = 0x0C;

			  	#if (0 == 1)
			   		#ifndef MX_PWM_ALT_ERROR
						clear_bit(MX_PWM_TRIS1a, MX_PWM_1a);
			   		#endif
			  	#else
					clear_bit(MX_PWM_TRIS1, MX_PWM_1);
			  	#endif
			}
	  	#endif

	  	#if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccp2con = 0x0C;
			  	#if (0 == 2)
			   		#ifndef MX_PWM_ALT_ERROR
						clear_bit(MX_PWM_TRIS2a, MX_PWM_2a);
			   		#endif
			 	#else
					clear_bit(MX_PWM_TRIS2, MX_PWM_2);
			  	#endif
		   }
	  	#endif
	  #endif

	  #ifdef MX_PWM_ALT_ERROR
	   #undef MX_PWM_ALT_ERROR
	  #endif

	#endif

}

void FCD_PWM0_Disable(char nIdx)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL
		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_Module_WR(ModID, 321, 1, 1, 0);
		MIAC_Module_GetAck(ModID, 321, 20);

		#undef MX_MIAC_EXTERNAL

	#else

	 	#ifndef MX_PWM		//error checking
			#error "This chip does not have PWM capability"
	  	#else
		  	#if (MX_PWM_CNT >= 1)
				if (nIdx == 1)
				{
					ccp1con = 0x00;
				}
		  	#endif

		  	#if (MX_PWM_CNT >= 2)
				if (nIdx == 2)
				{
					ccp2con = 0x00;
				}
		  	#endif
	 	#endif
	#endif

}

void FCD_PWM0_SetDutyCycle(char nIdx, char nDuty)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif

	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[1] = nDuty;
		MIAC_Module_WR(ModID, 322, 2, 1, 0);
		MIAC_Module_GetAck(ModID, 322, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  //error checking
	  #ifndef MX_PWM
		#error "This chip does not have PWM capability"
	  #else
		  #if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccpr1l = nDuty;
			}
		  #endif

		  #if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccpr2l = nDuty;
			}
		  #endif
	 #endif
	#endif

}

void FCD_PWM0_ChangePeriod(char nPeriodVal, char nPrescalerVal)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nPeriodVal;
		MIAC_CAN_TX[1] = nPrescalerVal;
		MIAC_CAN_TX[2] = (nPrescalerVal >> 8);
		MIAC_Module_WR(ModID, 323, 3, 1, 0);
		MIAC_Module_GetAck(ModID, 323, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  //error checking
	  #ifndef MX_PWM
			#error "This chip does not have PWM capability"
	  #else
	    pr2 = nPeriodVal;

	    switch (nPrescalerVal)
	    {
	        case 1:
	            t2con = 0x04;
	            break;

	        case 4:
	            t2con = 0x05;
	            break;

	        case 16:
	            t2con = 0x06;
	            break;
	    }
	  #endif
	#endif

}

void FCD_PWM0_SetDutyCycle10bit(char nIdx, short nDuty)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[2] = nDuty;
		MIAC_CAN_TX[1] = (nDuty >> 8);
		MIAC_Module_WR(ModID, 324, 3, 1, 0);
		MIAC_Module_GetAck(ModID, 324, 20);

		#undef MX_MIAC_EXTERNAL
	#else

		char nCCPxCONtemp;

	  //error checking
	  #ifndef MX_PWM
	  	#error "This chip does not have PWM capability"
	  #else
		  #if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccpr1l = (nDuty & 0x3FC) >> 2;

				nDuty = (nDuty & 0x03) << 4;
				nCCPxCONtemp = (ccp1con & 0xCF) | nDuty;
				ccp1con = nCCPxCONtemp;
			}
		  #endif

		  #if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccpr2l = (nDuty & 0x3FC) >> 2;

				nDuty = (nDuty & 0x03) << 4;
				nCCPxCONtemp = (ccp2con & 0xCF) | nDuty;
				ccp2con = nCCPxCONtemp;
			}
		  #endif
	 #endif
	#endif

}

//Implémentations Macro

void FCM_initLed()
{
	
	//Définitions des variables locales
	char FCL_I;

	//Calcul
	//Calcul:
	//  initLed.i = 1
	FCL_I = 1;
	

	//Boucle
	//Boucle: Boucle 8 fois
	for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
	{
		//Sortie
		//Sortie: initLed.i -> PORTD
		trisd = 0x00;
		portd = FCL_I;


		//Pause
		//Pause: 100 ms
		delay_ms(100);


		//Sortie
		//Sortie: 0 -> PORTD
		trisd = 0x00;
		portd = 0;


		//Calcul
		//Calcul:
		//  initLed.i = initLed.i * 2
		FCL_I = FCL_I * 2;
		

	}


	//Calcul
	//Calcul:
	//  initLed.i = 128
	FCL_I = 128;
	

	//Boucle
	//Boucle: Boucle 8 fois
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
	{
		//Sortie
		//Sortie: initLed.i -> PORTD
		trisd = 0x00;
		portd = FCL_I;


		//Pause
		//Pause: 100 ms
		delay_ms(100);


		//Sortie
		//Sortie: 0 -> PORTD
		trisd = 0x00;
		portd = 0;


		//Calcul
		//Calcul:
		//  initLed.i = initLed.i / 2
		FCL_I = FCL_I / 2;
		

	}


}

void FCM_showBattLevel()
{
	
	//Définitions des variables locales
	char FCL_BATLEVEL;

	//Appel d'une Macro
	//Appel d'une Macro: showBattLevel.batLevel=getBat
	FCL_BATLEVEL = FCM_getBat();


	//Décision
	//Décision: showBattLevel.batLevel > 0?
	if (FCL_BATLEVEL > 0)
	{
		//Sortie
		//Sortie: 1 -> D0
		trisd = trisd & 0xfe;
		if (1)
			portd = (portd & 0xfe) | 0x01;
		else
			portd = portd & 0xfe;


	} else {
		//Sortie
		//Sortie: 0 -> D0
		trisd = trisd & 0xfe;
		if (0)
			portd = (portd & 0xfe) | 0x01;
		else
			portd = portd & 0xfe;


	}


	//Décision
	//Décision: showBattLevel.batLevel > 36?
	if (FCL_BATLEVEL > 36)
	{
		//Sortie
		//Sortie: 1 -> D1
		trisd = trisd & 0xfd;
		if (1)
			portd = (portd & 0xfd) | 0x02;
		else
			portd = portd & 0xfd;


	} else {
		//Sortie
		//Sortie: 0 -> D1
		trisd = trisd & 0xfd;
		if (0)
			portd = (portd & 0xfd) | 0x02;
		else
			portd = portd & 0xfd;


	}


	//Décision
	//Décision: showBattLevel.batLevel > 72?
	if (FCL_BATLEVEL > 72)
	{
		//Sortie
		//Sortie: 1 -> D2
		trisd = trisd & 0xfb;
		if (1)
			portd = (portd & 0xfb) | 0x04;
		else
			portd = portd & 0xfb;


	} else {
		//Sortie
		//Sortie: 0 -> D2
		trisd = trisd & 0xfb;
		if (0)
			portd = (portd & 0xfb) | 0x04;
		else
			portd = portd & 0xfb;


	}


	//Décision
	//Décision: showBattLevel.batLevel > 108?
	if (FCL_BATLEVEL > 108)
	{
		//Sortie
		//Sortie: 1 -> D3
		trisd = trisd & 0xf7;
		if (1)
			portd = (portd & 0xf7) | 0x08;
		else
			portd = portd & 0xf7;


	} else {
		//Sortie
		//Sortie: 0 -> D3
		trisd = trisd & 0xf7;
		if (0)
			portd = (portd & 0xf7) | 0x08;
		else
			portd = portd & 0xf7;


	}


	//Décision
	//Décision: showBattLevel.batLevel > 145?
	if (FCL_BATLEVEL > 145)
	{
		//Sortie
		//Sortie: 1 -> D4
		trisd = trisd & 0xef;
		if (1)
			portd = (portd & 0xef) | 0x10;
		else
			portd = portd & 0xef;


	} else {
		//Sortie
		//Sortie: 0 -> D4
		trisd = trisd & 0xef;
		if (0)
			portd = (portd & 0xef) | 0x10;
		else
			portd = portd & 0xef;


	}


	//Décision
	//Décision: showBattLevel.batLevel > 181?
	if (FCL_BATLEVEL > 181)
	{
		//Sortie
		//Sortie: 1 -> D5
		trisd = trisd & 0xdf;
		if (1)
			portd = (portd & 0xdf) | 0x20;
		else
			portd = portd & 0xdf;


	} else {
		//Sortie
		//Sortie: 0 -> D5
		trisd = trisd & 0xdf;
		if (0)
			portd = (portd & 0xdf) | 0x20;
		else
			portd = portd & 0xdf;


	}


	//Décision
	//Décision: showBattLevel.batLevel > 217?
	if (FCL_BATLEVEL > 217)
	{
		//Sortie
		//Sortie: 1 -> D6
		trisd = trisd & 0xbf;
		if (1)
			portd = (portd & 0xbf) | 0x40;
		else
			portd = portd & 0xbf;


	} else {
		//Sortie
		//Sortie: 0 -> D6
		trisd = trisd & 0xbf;
		if (0)
			portd = (portd & 0xbf) | 0x40;
		else
			portd = portd & 0xbf;


	}


	//Décision
	//Décision: showBattLevel.batLevel > 254?
	if (FCL_BATLEVEL > 254)
	{
		//Sortie
		//Sortie: 1 -> D7
		trisd = trisd & 0x7f;
		if (1)
			portd = (portd & 0x7f) | 0x80;
		else
			portd = portd & 0x7f;


	} else {
		//Sortie
		//Sortie: 0 -> D7
		trisd = trisd & 0x7f;
		if (0)
			portd = (portd & 0x7f) | 0x80;
		else
			portd = portd & 0x7f;


	}


}

char FCM_isBattLevelOK(char FCL_PRCT)
{
	
	//Définitions des variables locales
	char FCL_BATTLEVEL;

	char FCR_RETVAL;

	//Appel d'une Macro
	//Appel d'une Macro: isBattLevelOK.battLevel=getBat
	FCL_BATTLEVEL = FCM_getBat();


	//Décision
	//Décision: isBattLevelOK.battLevel >= isBattLevelOK.prct?
	if (FCL_BATTLEVEL >= FCL_PRCT)
	{
		//Calcul
		//Calcul:
		//  isBattLevelOK.Return = true
		FCR_RETVAL = FCV_TRUE;
		

	} else {
		//Calcul
		//Calcul:
		//  isBattLevelOK.Return = false
		FCR_RETVAL = FCV_FALSE;
		

	}


	return (FCR_RETVAL);
}

char FCM_getBat()
{
	
	char FCR_RETVAL;

	//Appel de la Routine Composant
	//Appel de la Routine Composant: getBat.Return=ADC(0)::Lire_comme_Octet
	FCR_RETVAL = FCD_ADC0_ReadAsByte();


	return (FCR_RETVAL);
}

char FCM_getTrou(short FCL_TIMEOUT)
{
	
	//Définitions des variables locales
	short FCL_T;
	char FCL_CAPT;

	char FCR_RETVAL;

	//Calcul
	//Calcul:
	//  getTrou.Return = false
	//  getTrou.t = 0
	FCR_RETVAL = FCV_FALSE;
	FCL_T = 0;
	

	//Boucle
	//Boucle: Tant que getTrou.t < getTrou.timeout && getTrou.Return == false
	while (1)
	{
		//Entrée
		//Entrée: C0 -> getTrou.capt
		trisc = trisc | 0x01;
		FCL_CAPT = ((portc & 0x01) == 0x01);


		//Décision
		//Décision: getTrou.capt?
		if (FCL_CAPT)
		{
			//Calcul
			//Calcul:
			//  getTrou.Return = true
			FCR_RETVAL = FCV_TRUE;
			

		}


		//Calcul
		//Calcul:
		//  getTrou.t = getTrou.t + 25
		FCL_T = FCL_T + 25;
		

		//Pause
		//Pause: 25 ms
		delay_ms(25);


		if ((FCL_T < FCL_TIMEOUT && FCR_RETVAL == FCV_FALSE) == 0) break;
	}


	return (FCR_RETVAL);
}

void main()
{
	
	//Initialisation
	adcon1 = 0x0F;
	ucfg = 0x08;
cr_bit(pie2, USBIE);


	//Code d'initialisation d'Interruption
	


	//Calcul
	//Calcul:
	//  true = 1
	//  false = 0
	FCV_TRUE = 1;
	FCV_FALSE = 0;
	

	//Appel d'une Macro
	//Appel d'une Macro: initLed
	FCM_initLed();


	//Boucle
	//Boucle: Tant que 1
	while (1)
	{
		//Appel d'une Macro
		//Appel d'une Macro: showBattLevel
		FCM_showBattLevel();


		//Appel d'une Macro
		//Appel d'une Macro: battLevelOk=isBattLevelOK(128)
		FCV_BATTLEVELOK = FCM_isBattLevelOK(128);


		//Décision
		//Décision: battLevelOk?
		if (FCV_BATTLEVELOK)
		{
			//Commentaire:
			//C'est parti !!!


			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::Enable(1)
			FCD_PWM0_Enable(1);


			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::Enable(2)
			FCD_PWM0_Enable(2);


			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::SetDutyCycle(1, 128)
			FCD_PWM0_SetDutyCycle(1, 128);


			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::SetDutyCycle(2, 128)
			FCD_PWM0_SetDutyCycle(2, 128);


			//Appel d'une Macro
			//Appel d'une Macro: isTrou=getTrou(1000)
			FCV_ISTROU = FCM_getTrou(1000);


			//Décision
			//Décision: isTrou?
			if (FCV_ISTROU)
			{
				//Appel de la Routine Composant
				//Appel de la Routine Composant: PWM(0)::Disable(1)
				FCD_PWM0_Disable(1);


				//Appel de la Routine Composant
				//Appel de la Routine Composant: PWM(0)::Disable(2)
				FCD_PWM0_Disable(2);


				//Pause
				//Pause: 1000 s
				delay_s(255);
				delay_s(255);
				delay_s(255);
				delay_s(235);


				//Commentaire:
				//Dépliage pont !!!!!


			}


		} else {
			//Commentaire:
			//Nope :(


			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::Disable(1)
			FCD_PWM0_Disable(1);


			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::Disable(2)
			FCD_PWM0_Disable(2);


		}


	}


	mainendloop: goto mainendloop;
}

void MX_INTERRUPT_MACRO(void)
{
}



