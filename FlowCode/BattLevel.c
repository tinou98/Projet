//************************************************************************************
//**  
//**  File name:     P:\SI\Projet\FlowCode\BattLevel.c
//**  Generated by:  Flowcode v4.5.18.74
//**  Date:          Friday, April 10, 2015 11:16:40
//**  Licence:       10 User
//**  Registered to: LYCEE-STMARC38-02
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL 
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Définir pour microcontrôleur
#define P18F4455
#define MX_EE
#define MX_EE_TYPE3
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_BCB
#define MX_SPI_SDI 0
#define MX_SPI_SDO 7
#define MX_SPI_SCK 1
#define MX_UART
#define MX_UART_C
#define MX_UART_TX 6
#define MX_UART_RX 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_B
#define MX_I2C_SDA 0
#define MX_I2C_SCL 1
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 2
#define MX_PWM_TRIS2 trisc
#define MX_PWM_2 1
#define MX_PWM_TRIS2a trisb
#define MX_PWM_2a 3
#define MX_USB_TYPE1

//Fonctions
#define MX_CLK_SPEED 48000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic18.h>
#endif

//Données de Configuration
#ifdef _BOOSTC
#pragma DATA 0x300000, 0x20
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0xe
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0x3e
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0x1e
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x81
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0x81
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0x80
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xa0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif

//Fonctions internes
#include "C:\Program Files\Matrix Multimedia\Flowcode V4\FCD\internals.h"

//Déclarations de fonction Macro
void FCM_initLed();
void FCM_showLevel(char FCL_LEVEL);
char FCM_isBattLevelOK(char FCL_PRCT);
char FCM_getBat();
char FCM_getTrou(short FCL_TIMEOUT);
void FCM_move(short FCL_VITESSE, short FCL_SENS, short FCL_DEGRE);
void FCM_align();
void FCM_verrin(char FCL_MONTE);
char FCM_getTrouState(char FCL_NB);


//Déclarations de Variable
char FCV_STOP;
char FCV_PB;
char FCV__1;
char FCV_I;
char FCV__2;
char FCV__3;
char FCV_RIGHT;
char FCV_LEFT;
char FCV_DROIT;
char FCV_ARRIERE;
char FCV_ISTROU;
char FCV_BATTLEVELOK;
char FCV_FALSE;
char FCV_TRUE;
char FCV_AVANT;

char FCLV_LOOP1;
char FCLV_LOOP2;



//PWM(0): //Defines:

/**** Macro Substitutions ****
255 = Timer 2 Rollover Value
0x04 = Timer 2 Prescaler Value
-1 = MIAC System ID
0 = Alternate Pin FCD_PWM0_Enable
******************************/




//PWM(0): //Déclarations de fonction Macro

void FCD_PWM0_Enable(char nIdx);
void FCD_PWM0_Disable(char nIdx);
void FCD_PWM0_SetDutyCycle(char nIdx, char nDuty);
void FCD_PWM0_ChangePeriod(char nPeriodVal, char nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(char nIdx, short nDuty);


//ADC(0): //Defines:

/**** Macro Substitutions ****
12 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
0 = VRef+ Option
500 = VRef Voltage x 0.01V
0 = MIAC System ordinal
0 = MIAC System module type
******************************/




//ADC(0): //Déclarations de fonction Macro

void FCD_ADC0_SampleADC();
char FCD_ADC0_ReadAsByte();
short FCD_ADC0_ReadAsInt();
float FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);


//ADC(2): //Defines:

/**** Macro Substitutions ****
9 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
0 = VRef+ Option
500 = VRef Voltage x 0.01V
0 = MIAC System ordinal
0 = MIAC System module type
******************************/




//ADC(2): //Déclarations de fonction Macro

void FCD_ADC2_SampleADC();
char FCD_ADC2_ReadAsByte();
short FCD_ADC2_ReadAsInt();
float FCD_ADC2_ReadAsVoltage();
void FCD_ADC2_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);


//ADC(3): //Defines:

/**** Macro Substitutions ****
9 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
0 = VRef+ Option
500 = VRef Voltage x 0.01V
0 = MIAC System ordinal
0 = MIAC System module type
******************************/




//ADC(3): //Déclarations de fonction Macro

void FCD_ADC3_SampleADC();
char FCD_ADC3_ReadAsByte();
short FCD_ADC3_ReadAsInt();
float FCD_ADC3_ReadAsVoltage();
void FCD_ADC3_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);


//Stepper(0): //Defines:

/**** Macro Substitutions ****
portd = Coil 1 Port Register
trisd = Coil 1 Data Direction Register
0 = Coil 1 Pin
portd = Coil 2 Port Register
trisd = Coil 2 Data Direction Register
1 = Coil 2 Pin
portd = Coil 3 Port Register
trisd = Coil 3 Data Direction Register
2 = Coil 3 Pin
portd = Coil 4 Port Register
trisd = Coil 4 Data Direction Register
7 = Coil 4 Pin
0 = Step Type - 0 = half step, 1 = full step (2-2), 2 = wave (1-1)
0 = Motor Type - 0 = bipolar/unipolar +ve, 1 = unipolar -ve
0 = Number of Full Steps Per Revolution
0 = Unused
Stepper_655906 = Unique Component Identifier
******************************/

//common defines
#define MX_Stepper_655906_PORT1			portd	//0
#define MX_Stepper_655906_TRIS1			trisd
#define MX_Stepper_655906_PIN1			0
#define MX_Stepper_655906_PORT2			portd	//1
#define MX_Stepper_655906_TRIS2			trisd
#define MX_Stepper_655906_PIN2			1
#define MX_Stepper_655906_PORT3			portd	//2
#define MX_Stepper_655906_TRIS3			trisd
#define MX_Stepper_655906_PIN3			2
#define MX_Stepper_655906_PORT4			portd	//3
#define MX_Stepper_655906_TRIS4			trisd
#define MX_Stepper_655906_PIN4			7
#define MX_Stepper_655906_STEP_TYPE		0	//0 = half step, 1 = full step (2-2), 2 = wave (1-1)
#define MX_Stepper_655906_WINDING_TYPE	0	//0 = bipolar/unipolar +ve, 1 = unipolar -ve


#if (MX_Stepper_655906_WINDING_TYPE == 2)
	char Stepper_655906_pattern[8] = {0x06, 0x0e, 0x0a, 0x0b, 0x09, 0x0d, 0x05, 0x07};
#else
	char Stepper_655906_pattern[8] = {0x09, 0x01, 0x05, 0x04, 0x06, 0x02, 0x0a, 0x08};
#endif


#if (MX_Stepper_655906_STEP_TYPE == 0)
	#define MX_Stepper_655906_INC_STEP	1
#else
	#define MX_Stepper_655906_INC_STEP	2
#endif

char Stepper_655906_phase = 0;
char Stepper_655906_enabled = 0;




//Stepper(0): //Déclarations de fonction Macro

void FCD_Stepper0_IncrementStep();
void FCD_Stepper0_DecrementStep();
void FCD_Stepper0_EnableMotor();
void FCD_Stepper0_DisableMotor();

//Définitions supplémentaires
#define MOTEUR_AVANCE 1



//PWM(0): //Implémentations Macro


void FCD_PWM0_Enable(char nIdx)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif

	#ifdef MX_MIAC_EXTERNAL
		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[1] = 255;
		MIAC_CAN_TX[2] = 0x04;
		MIAC_Module_WR(ModID, 320, 3, 1, 0);
		MIAC_Module_GetAck(ModID + 32, 320, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  #ifndef MX_PWM		//error checking
		#error "This chip does not have PWM capability"
	  #else
		#ifndef MX_PWM_CNT
			#error "FCD file error (no MX_PWM_CNT)"
		#endif
		#if (MX_PWM_CNT < 1)
			#error "FCD file error (MX_PWM_CNT < 1)"
		#endif
		//#if (MX_PWM_CNT > 2)
		//	#error "FCD file error (MX_PWM_CNT > 2)"
		//#endif
		#ifndef MX_PWM_TRIS1
			#error "FCD file error (no MX_PWM_TRIS1)"
		#endif
		#ifndef MX_PWM_1
			#error "FCD file error (no MX_PWM_1)"
		#endif
	    #if (MX_PWM_CNT == 2)
	      	#ifndef MX_PWM_TRIS2
				#error "FCD file error (no MX_PWM_TRIS2)"
	      	#endif
	      	#ifndef MX_PWM_2
				#error "FCD file error (no MX_PWM_2)"
	      	#endif
	    #endif
	    #if (0 == 1)
	      	#ifndef MX_PWM_TRIS1a
				#error "PWM component error (using alternative, but no MX_PWM_TRIS1a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	      	#ifndef MX_PWM_1a
				#error "PWM component error (using alternative, but no MX_PWM_1a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	    #endif
	    #if (0 == 2)
	      	#ifndef MX_PWM_TRIS2a
				#error "PWM component error (using alternative, but no MX_PWM_TRIS2a)"
	  			#define MX_PWM_ALT_ERROR
	      	#endif
	      	#ifndef MX_PWM_2a
				#error "PWM component error (using alternative, but no MX_PWM_2a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	    #endif

	 	#ifdef MX_PWM
			pr2 = 255;
			t2con = 0x04;
		#endif

	  	#if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccp1con = 0x0C;

			  	#if (0 == 1)
			   		#ifndef MX_PWM_ALT_ERROR
						clear_bit(MX_PWM_TRIS1a, MX_PWM_1a);
			   		#endif
			  	#else
					clear_bit(MX_PWM_TRIS1, MX_PWM_1);
			  	#endif
			}
	  	#endif

	  	#if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccp2con = 0x0C;
			  	#if (0 == 2)
			   		#ifndef MX_PWM_ALT_ERROR
						clear_bit(MX_PWM_TRIS2a, MX_PWM_2a);
			   		#endif
			 	#else
					clear_bit(MX_PWM_TRIS2, MX_PWM_2);
			  	#endif
		   }
	  	#endif
	  #endif

	  #ifdef MX_PWM_ALT_ERROR
	   #undef MX_PWM_ALT_ERROR
	  #endif

	#endif

}

void FCD_PWM0_Disable(char nIdx)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL
		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_Module_WR(ModID, 321, 1, 1, 0);
		MIAC_Module_GetAck(ModID, 321, 20);

		#undef MX_MIAC_EXTERNAL

	#else

	 	#ifndef MX_PWM		//error checking
			#error "This chip does not have PWM capability"
	  	#else
		  	#if (MX_PWM_CNT >= 1)
				if (nIdx == 1)
				{
					ccp1con = 0x00;
				}
		  	#endif

		  	#if (MX_PWM_CNT >= 2)
				if (nIdx == 2)
				{
					ccp2con = 0x00;
				}
		  	#endif
	 	#endif
	#endif

}

void FCD_PWM0_SetDutyCycle(char nIdx, char nDuty)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif

	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[1] = nDuty;
		MIAC_Module_WR(ModID, 322, 2, 1, 0);
		MIAC_Module_GetAck(ModID, 322, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  //error checking
	  #ifndef MX_PWM
		#error "This chip does not have PWM capability"
	  #else
		  #if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccpr1l = nDuty;
			}
		  #endif

		  #if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccpr2l = nDuty;
			}
		  #endif
	 #endif
	#endif

}

void FCD_PWM0_ChangePeriod(char nPeriodVal, char nPrescalerVal)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nPeriodVal;
		MIAC_CAN_TX[1] = nPrescalerVal;
		MIAC_CAN_TX[2] = (nPrescalerVal >> 8);
		MIAC_Module_WR(ModID, 323, 3, 1, 0);
		MIAC_Module_GetAck(ModID, 323, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  //error checking
	  #ifndef MX_PWM
			#error "This chip does not have PWM capability"
	  #else
	    pr2 = nPeriodVal;

	    switch (nPrescalerVal)
	    {
	        case 1:
	            t2con = 0x04;
	            break;

	        case 4:
	            t2con = 0x05;
	            break;

	        case 16:
	            t2con = 0x06;
	            break;
	    }
	  #endif
	#endif

}

void FCD_PWM0_SetDutyCycle10bit(char nIdx, short nDuty)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[2] = nDuty;
		MIAC_CAN_TX[1] = (nDuty >> 8);
		MIAC_Module_WR(ModID, 324, 3, 1, 0);
		MIAC_Module_GetAck(ModID, 324, 20);

		#undef MX_MIAC_EXTERNAL
	#else

		char nCCPxCONtemp;

	  //error checking
	  #ifndef MX_PWM
	  	#error "This chip does not have PWM capability"
	  #else
		  #if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccpr1l = (nDuty & 0x3FC) >> 2;

				nDuty = (nDuty & 0x03) << 4;
				nCCPxCONtemp = (ccp1con & 0xCF) | nDuty;
				ccp1con = nCCPxCONtemp;
			}
		  #endif

		  #if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccpr2l = (nDuty & 0x3FC) >> 2;

				nDuty = (nDuty & 0x03) << 4;
				nCCPxCONtemp = (ccp2con & 0xCF) | nDuty;
				ccp2con = nCCPxCONtemp;
			}
		  #endif
	 #endif
	#endif

}



//ADC(0): //Implémentations Macro


void FCD_ADC0_SampleADC()
{
	
	/*******Supported Devices******************************************************************
	// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
	// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
	// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
	// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
	// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
	// 18F4680, 18F4682, 18F4685
	******************************************************************************************/

	#ifndef MX_MIAC

		#define MX_ADC_CHANNEL		12
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		0

		//set up ADC conversion
		char old_tris, cnt;
		adcon2 = MX_ADC_CONV_SP & 0x07;

		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x0E;
		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x0D;
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x0C;
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x08
			adcon1 = 0x0B;
			#if (MX_ADC_VREF_OPT != 0)
				#error "Target device is currently using AN3 for VREF+"
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x20
			adcon1 = 0x0A;
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x09;
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x08;
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x07;
		#endif
		#if (MX_ADC_CHANNEL == 8)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x06;
		#endif
		#if (MX_ADC_CHANNEL == 9)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x05;
		#endif
		#if (MX_ADC_CHANNEL == 10)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x04;
		#endif
		#if (MX_ADC_CHANNEL == 11)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x03;
		#endif
		#if (MX_ADC_CHANNEL == 12)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x02;
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#error "ADC Type 13 conversion code error - please contact technical support"
		#endif

		//assign VREF functionality
		#if (MX_ADC_VREF_OPT != 0)
			st_bit(adcon1, VCFG0);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;

		//turn ADC on
		adcon0 = 0x01 | (MX_ADC_CHANNEL << 2);

		//wait the acquisition time
		cnt = 0;
		while (cnt < MX_ADC_SAMP_TIME) cnt++;

		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x02;
		while (adcon0 & 0x02);

		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
		adcon1 = 0x0f;
		adcon0 = 0x00;

		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CHANNEL
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

	#endif

}

char FCD_ADC0_ReadAsByte()
{
	
	#ifdef MX_MIAC_SYSTEM
		int iSample;

		iSample = FCD_ADC0_ReadAsInt();

		return (iSample >> 2);
	#else

		FCD_ADC0_SampleADC();

		return adresh;
	#endif

}

short FCD_ADC0_ReadAsInt()
{
	
		short iRetVal;

	#ifdef MX_MIAC_SYSTEM

	  #if (0 == MX_MIAC_MM_MIAC_BASE)
	  	iRetVal = MIAC_Master_InputANA10(12);
	  #else
		unsigned int ModID = ((0 << 5) + 0) << 9;

		MIAC_CAN_TX[0] = 12;

		MIAC_Module_WR(ModID, 289, 1,1,0);
		MIAC_Module_GetAck(ModID + 32, 289, 200);
		iRetVal = ((MIAC_CAN_RX[0] << 8) | MIAC_CAN_RX[1]) >> 2;
	  #endif
	#else
		FCD_ADC0_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);
	#endif
		return (iRetVal);

}

float FCD_ADC0_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC0_ReadAsInt();											//Read as 10-bit Integer

		fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
		fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
		fSample = float32_from_int32(iSample);							//Convert to floating point variable
		fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//ADC(2): //Implémentations Macro


void FCD_ADC2_SampleADC()
{
	
	/*******Supported Devices******************************************************************
	// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
	// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
	// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
	// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
	// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
	// 18F4680, 18F4682, 18F4685
	******************************************************************************************/

	#ifndef MX_MIAC

		#define MX_ADC_CHANNEL		9
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		0

		//set up ADC conversion
		char old_tris, cnt;
		adcon2 = MX_ADC_CONV_SP & 0x07;

		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x0E;
		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x0D;
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x0C;
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x08
			adcon1 = 0x0B;
			#if (MX_ADC_VREF_OPT != 0)
				#error "Target device is currently using AN3 for VREF+"
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x20
			adcon1 = 0x0A;
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x09;
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x08;
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x07;
		#endif
		#if (MX_ADC_CHANNEL == 8)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x06;
		#endif
		#if (MX_ADC_CHANNEL == 9)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x05;
		#endif
		#if (MX_ADC_CHANNEL == 10)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x04;
		#endif
		#if (MX_ADC_CHANNEL == 11)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x03;
		#endif
		#if (MX_ADC_CHANNEL == 12)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x02;
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#error "ADC Type 13 conversion code error - please contact technical support"
		#endif

		//assign VREF functionality
		#if (MX_ADC_VREF_OPT != 0)
			st_bit(adcon1, VCFG0);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;

		//turn ADC on
		adcon0 = 0x01 | (MX_ADC_CHANNEL << 2);

		//wait the acquisition time
		cnt = 0;
		while (cnt < MX_ADC_SAMP_TIME) cnt++;

		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x02;
		while (adcon0 & 0x02);

		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
		adcon1 = 0x0f;
		adcon0 = 0x00;

		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CHANNEL
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

	#endif

}

char FCD_ADC2_ReadAsByte()
{
	
	#ifdef MX_MIAC_SYSTEM
		int iSample;

		iSample = FCD_ADC2_ReadAsInt();

		return (iSample >> 2);
	#else

		FCD_ADC2_SampleADC();

		return adresh;
	#endif

}

short FCD_ADC2_ReadAsInt()
{
	
		short iRetVal;

	#ifdef MX_MIAC_SYSTEM

	  #if (0 == MX_MIAC_MM_MIAC_BASE)
	  	iRetVal = MIAC_Master_InputANA10(9);
	  #else
		unsigned int ModID = ((0 << 5) + 0) << 9;

		MIAC_CAN_TX[0] = 9;

		MIAC_Module_WR(ModID, 289, 1,1,0);
		MIAC_Module_GetAck(ModID + 32, 289, 200);
		iRetVal = ((MIAC_CAN_RX[0] << 8) | MIAC_CAN_RX[1]) >> 2;
	  #endif
	#else
		FCD_ADC2_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);
	#endif
		return (iRetVal);

}

float FCD_ADC2_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC2_ReadAsInt();											//Read as 10-bit Integer

		fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
		fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
		fSample = float32_from_int32(iSample);							//Convert to floating point variable
		fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC2_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC2_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//ADC(3): //Implémentations Macro


void FCD_ADC3_SampleADC()
{
	
	/*******Supported Devices******************************************************************
	// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
	// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
	// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
	// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
	// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
	// 18F4680, 18F4682, 18F4685
	******************************************************************************************/

	#ifndef MX_MIAC

		#define MX_ADC_CHANNEL		9
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		0

		//set up ADC conversion
		char old_tris, cnt;
		adcon2 = MX_ADC_CONV_SP & 0x07;

		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x0E;
		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x0D;
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x0C;
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x08
			adcon1 = 0x0B;
			#if (MX_ADC_VREF_OPT != 0)
				#error "Target device is currently using AN3 for VREF+"
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x20
			adcon1 = 0x0A;
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x09;
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x08;
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x07;
		#endif
		#if (MX_ADC_CHANNEL == 8)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x06;
		#endif
		#if (MX_ADC_CHANNEL == 9)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x05;
		#endif
		#if (MX_ADC_CHANNEL == 10)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x04;
		#endif
		#if (MX_ADC_CHANNEL == 11)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x03;
		#endif
		#if (MX_ADC_CHANNEL == 12)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x02;
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#error "ADC Type 13 conversion code error - please contact technical support"
		#endif

		//assign VREF functionality
		#if (MX_ADC_VREF_OPT != 0)
			st_bit(adcon1, VCFG0);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;

		//turn ADC on
		adcon0 = 0x01 | (MX_ADC_CHANNEL << 2);

		//wait the acquisition time
		cnt = 0;
		while (cnt < MX_ADC_SAMP_TIME) cnt++;

		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x02;
		while (adcon0 & 0x02);

		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
		adcon1 = 0x0f;
		adcon0 = 0x00;

		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CHANNEL
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

	#endif

}

char FCD_ADC3_ReadAsByte()
{
	
	#ifdef MX_MIAC_SYSTEM
		int iSample;

		iSample = FCD_ADC3_ReadAsInt();

		return (iSample >> 2);
	#else

		FCD_ADC3_SampleADC();

		return adresh;
	#endif

}

short FCD_ADC3_ReadAsInt()
{
	
		short iRetVal;

	#ifdef MX_MIAC_SYSTEM

	  #if (0 == MX_MIAC_MM_MIAC_BASE)
	  	iRetVal = MIAC_Master_InputANA10(9);
	  #else
		unsigned int ModID = ((0 << 5) + 0) << 9;

		MIAC_CAN_TX[0] = 9;

		MIAC_Module_WR(ModID, 289, 1,1,0);
		MIAC_Module_GetAck(ModID + 32, 289, 200);
		iRetVal = ((MIAC_CAN_RX[0] << 8) | MIAC_CAN_RX[1]) >> 2;
	  #endif
	#else
		FCD_ADC3_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);
	#endif
		return (iRetVal);

}

float FCD_ADC3_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC3_ReadAsInt();											//Read as 10-bit Integer

		fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
		fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
		fSample = float32_from_int32(iSample);							//Convert to floating point variable
		fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC3_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC3_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//Stepper(0): //Implémentations Macro


void FCD_Stepper0_IncrementStep()
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if (portd != MX_MIAC_MM_MIAC_BASE)

		unsigned int ModID = ((trisd << 5) + portd) << 9;
	  #endif
	#endif

		char pattern_now;

		if( Stepper_655906_enabled)
		{
			Stepper_655906_phase = (Stepper_655906_phase + MX_Stepper_655906_INC_STEP);	//increment step

			#if (MX_Stepper_655906_STEP_TYPE == 1)
				Stepper_655906_phase &=0x06;		//full step, even index
			#endif

			#if (MX_Stepper_655906_STEP_TYPE == 2)								//full step, odd index
				Stepper_655906_phase |=0x01;
			#endif

			Stepper_655906_phase &= 0x07;
			pattern_now = Stepper_655906_pattern[Stepper_655906_phase];


		  #ifdef MX_MIAC_SYSTEM
	  		#if (portd != MX_MIAC_MM_MIAC_BASE)
				MIAC_CAN_TX[0] = 0;
				MIAC_CAN_TX[1] = 1;
				MIAC_CAN_TX[2] = 2;
				MIAC_CAN_TX[3] = 7;
				MIAC_CAN_TX[4] = pattern_now;
				MIAC_Module_WR(ModID, 512, 5,1,0);
				MIAC_Module_GetAck(ModID + 32, 512, 20);
			#else
				if(test_bit(pattern_now, 0))
				{
					if(0 > 12)
						FCD_MIAC0_OutputON(0 - 12);
					else
						FCD_MIAC0_RelayON(0 - 8);
				}else{
					if(0 > 12)
						FCD_MIAC0_OutputOFF(0 - 12);
					else
						FCD_MIAC0_RelayOFF(0 - 8);
				}

				if(test_bit(pattern_now, 1))
				{
					if(1 > 12)
						FCD_MIAC0_OutputON(1 - 12);
					else
						FCD_MIAC0_RelayON(1 - 8);
				}else{
					if(1 > 12)
						FCD_MIAC0_OutputOFF(1 - 12);
					else
						FCD_MIAC0_RelayOFF(1 - 8);
				}

				if(test_bit(pattern_now, 2))
				{
					if(2 > 12)
						FCD_MIAC0_OutputON(2 - 12);
					else
						FCD_MIAC0_RelayON(2 - 8);
				}else{
					if(2 > 12)
						FCD_MIAC0_OutputOFF(2 - 12);
					else
						FCD_MIAC0_RelayOFF(2 - 8);
				}

				if(test_bit(pattern_now, 3))
				{
					if(7 > 12)
						FCD_MIAC0_OutputON(7 - 12);
					else
						FCD_MIAC0_RelayON(7 - 8);
				}else{
					if(7 > 12)
						FCD_MIAC0_OutputOFF(7 - 12);
					else
						FCD_MIAC0_RelayOFF(7 - 8);
				}
	  		#endif
		  #else
			if(test_bit(pattern_now, 0)) set_bit (MX_Stepper_655906_PORT1, MX_Stepper_655906_PIN1);
			else clear_bit (MX_Stepper_655906_PORT1, MX_Stepper_655906_PIN1);
			if(test_bit(pattern_now, 1)) set_bit (MX_Stepper_655906_PORT2, MX_Stepper_655906_PIN2);
			else clear_bit (MX_Stepper_655906_PORT2, MX_Stepper_655906_PIN2);
			if(test_bit(pattern_now, 2)) set_bit (MX_Stepper_655906_PORT3, MX_Stepper_655906_PIN3);
			else clear_bit (MX_Stepper_655906_PORT3, MX_Stepper_655906_PIN3);
			if(test_bit(pattern_now, 3)) set_bit (MX_Stepper_655906_PORT4, MX_Stepper_655906_PIN4);
			else clear_bit (MX_Stepper_655906_PORT4, MX_Stepper_655906_PIN4);
		  #endif
		}
}

void FCD_Stepper0_DecrementStep()
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if (portd != MX_MIAC_MM_MIAC_BASE)

		unsigned int ModID = ((trisd << 5) + portd) << 9;
	  #endif
	#endif
		char pattern_now;

		if( Stepper_655906_enabled)
		{

			Stepper_655906_phase = (Stepper_655906_phase - MX_Stepper_655906_INC_STEP);	//increment step

			#if (MX_Stepper_655906_STEP_TYPE == 1)
				Stepper_655906_phase &=0x06;		//full step, even index
			#endif

			#if (MX_Stepper_655906_STEP_TYPE == 2)			//full step, odd index
				Stepper_655906_phase |=0x01;
			#endif

			Stepper_655906_phase &= 0x07;
			pattern_now = Stepper_655906_pattern[Stepper_655906_phase];

		  #ifdef MX_MIAC_SYSTEM
	  		#if (portd != MX_MIAC_MM_MIAC_BASE)
				MIAC_CAN_TX[0] = 0;
				MIAC_CAN_TX[1] = 1;
				MIAC_CAN_TX[2] = 2;
				MIAC_CAN_TX[3] = 7;
				MIAC_CAN_TX[4] = pattern_now;
				MIAC_Module_WR(ModID, 512, 5,1,0);
				MIAC_Module_GetAck(ModID + 32, 512, 20);
			#else
				if(test_bit(pattern_now, 0))
				{
					if(0 > 12)
						FCD_MIAC0_OutputON(0 - 12);
					else
						FCD_MIAC0_RelayON(0 - 8);
				}else{
					if(0 > 12)
						FCD_MIAC0_OutputOFF(0 - 12);
					else
						FCD_MIAC0_RelayOFF(0 - 8);
				}

				if(test_bit(pattern_now, 1))
				{
					if(1 > 12)
						FCD_MIAC0_OutputON(1 - 12);
					else
						FCD_MIAC0_RelayON(1 - 8);
				}else{
					if(1 > 12)
						FCD_MIAC0_OutputOFF(1 - 12);
					else
						FCD_MIAC0_RelayOFF(1 - 8);
				}

				if(test_bit(pattern_now, 2))
				{
					if(2 > 12)
						FCD_MIAC0_OutputON(2 - 12);
					else
						FCD_MIAC0_RelayON(2 - 8);
				}else{
					if(2 > 12)
						FCD_MIAC0_OutputOFF(2 - 12);
					else
						FCD_MIAC0_RelayOFF(2 - 8);
				}

				if(test_bit(pattern_now, 3))
				{
					if(7 > 12)
						FCD_MIAC0_OutputON(7 - 12);
					else
						FCD_MIAC0_RelayON(7 - 8);
				}else{
					if(7 > 12)
						FCD_MIAC0_OutputOFF(7 - 12);
					else
						FCD_MIAC0_RelayOFF(7 - 8);
				}

	  		#endif
		  #else
			if(test_bit(pattern_now, 0)) set_bit (MX_Stepper_655906_PORT1, MX_Stepper_655906_PIN1);
			else clear_bit (MX_Stepper_655906_PORT1, MX_Stepper_655906_PIN1);
			if(test_bit(pattern_now, 1)) set_bit (MX_Stepper_655906_PORT2, MX_Stepper_655906_PIN2);
			else clear_bit (MX_Stepper_655906_PORT2, MX_Stepper_655906_PIN2);
			if(test_bit(pattern_now, 2)) set_bit (MX_Stepper_655906_PORT3, MX_Stepper_655906_PIN3);
			else clear_bit (MX_Stepper_655906_PORT3, MX_Stepper_655906_PIN3);
			if(test_bit(pattern_now, 3)) set_bit (MX_Stepper_655906_PORT4, MX_Stepper_655906_PIN4);
			else clear_bit (MX_Stepper_655906_PORT4, MX_Stepper_655906_PIN4);
		  #endif
		}
}

void FCD_Stepper0_EnableMotor()
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if (portd != MX_MIAC_MM_MIAC_BASE)

		unsigned int ModID = ((trisd << 5) + portd) << 9;
	  #endif
	#endif

		Stepper_655906_enabled = 1;

	  #ifdef MX_MIAC_SYSTEM
		#if (portd != MX_MIAC_MM_MIAC_BASE)
			MIAC_CAN_TX[0] = 0;
			MIAC_CAN_TX[1] = 1;
			MIAC_CAN_TX[2] = 2;
			MIAC_CAN_TX[3] = 7;
			MIAC_CAN_TX[4] = 0;
			MIAC_Module_WR(ModID, 512, 5,1,0);
			MIAC_Module_GetAck(ModID + 32, 512, 20);
		#else
			if(0 > 12)
				FCD_MIAC0_OutputOFF(0 - 12);
			else
				FCD_MIAC0_RelayOFF(0 - 8);

			if(1 > 12)
				FCD_MIAC0_OutputOFF(1 - 12);
			else
				FCD_MIAC0_RelayOFF(1 - 8);

			if(2 > 12)
				FCD_MIAC0_OutputOFF(2 - 12);
			else
				FCD_MIAC0_RelayOFF(2 - 8);

			if(7 > 12)
				FCD_MIAC0_OutputOFF(7 - 12);
			else
				FCD_MIAC0_RelayOFF(7 - 8);
		#endif
	  #else
		clear_bit(MX_Stepper_655906_TRIS1, MX_Stepper_655906_PIN1);
		clear_bit(MX_Stepper_655906_PORT1, MX_Stepper_655906_PIN1);
		clear_bit(MX_Stepper_655906_TRIS2, MX_Stepper_655906_PIN2);
		clear_bit(MX_Stepper_655906_PORT2, MX_Stepper_655906_PIN2);
		clear_bit(MX_Stepper_655906_TRIS3, MX_Stepper_655906_PIN3);
		clear_bit(MX_Stepper_655906_PORT3, MX_Stepper_655906_PIN3);
		clear_bit(MX_Stepper_655906_TRIS4, MX_Stepper_655906_PIN4);
		clear_bit(MX_Stepper_655906_PORT4, MX_Stepper_655906_PIN4);
	  #endif

}

void FCD_Stepper0_DisableMotor()
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if (portd != MX_MIAC_MM_MIAC_BASE)

		unsigned int ModID = ((trisd << 5) + portd) << 9;
	  #endif
	#endif

	  #ifdef MX_MIAC_SYSTEM
		#if (portd != MX_MIAC_MM_MIAC_BASE)
			MIAC_CAN_TX[0] = 0;
			MIAC_CAN_TX[1] = 1;
			MIAC_CAN_TX[2] = 2;
			MIAC_CAN_TX[3] = 7;
			MIAC_Module_WR(ModID, 513, 4,1,0);
			MIAC_Module_GetAck(ModID + 32, 513, 20);
		#else
			if(0 > 12)
				FCD_MIAC0_OutputOFF(0 - 12);
			else
				FCD_MIAC0_RelayOFF(0 - 8);

			if(1 > 12)
				FCD_MIAC0_OutputOFF(1 - 12);
			else
				FCD_MIAC0_RelayOFF(1 - 8);

			if(2 > 12)
				FCD_MIAC0_OutputOFF(2 - 12);
			else
				FCD_MIAC0_RelayOFF(2 - 8);

			if(7 > 12)
				FCD_MIAC0_OutputOFF(7 - 12);
			else
				FCD_MIAC0_RelayOFF(7 - 8);
		#endif
	  #else
		Stepper_655906_enabled = 0;
		set_bit(MX_Stepper_655906_TRIS1, MX_Stepper_655906_PIN1);
		clear_bit(MX_Stepper_655906_PORT1, MX_Stepper_655906_PIN1);
		set_bit(MX_Stepper_655906_TRIS2, MX_Stepper_655906_PIN2);
		clear_bit(MX_Stepper_655906_PORT2, MX_Stepper_655906_PIN2);
		set_bit(MX_Stepper_655906_TRIS3, MX_Stepper_655906_PIN3);
		clear_bit(MX_Stepper_655906_PORT3, MX_Stepper_655906_PIN3);
		set_bit(MX_Stepper_655906_TRIS4, MX_Stepper_655906_PIN4);
		clear_bit(MX_Stepper_655906_PORT4, MX_Stepper_655906_PIN4);
	  #endif
}

//Implémentations Macro

void FCM_initLed()
{
	
	//Définitions des variables locales
	char FCL_I;

	//Calcul
	//Calcul:
	//  initLed.i = 1
	FCL_I = 1;
	

	//Boucle
	//Boucle: Boucle 8 fois
	for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
	{
		//Sortie
		//Sortie: initLed.i -> PORTD
		trisd = 0x00;
		portd = FCL_I;


		//Pause
		//Pause: 100 ms
		delay_ms(100);


		//Sortie
		//Sortie: 0 -> PORTD
		trisd = 0x00;
		portd = 0;


		//Calcul
		//Calcul:
		//  initLed.i = initLed.i * 2
		FCL_I = FCL_I * 2;
		

	}


	//Calcul
	//Calcul:
	//  initLed.i = 128
	FCL_I = 128;
	

	//Boucle
	//Boucle: Boucle 8 fois
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
	{
		//Sortie
		//Sortie: initLed.i -> PORTD
		trisd = 0x00;
		portd = FCL_I;


		//Pause
		//Pause: 100 ms
		delay_ms(100);


		//Sortie
		//Sortie: 0 -> PORTD
		trisd = 0x00;
		portd = 0;


		//Calcul
		//Calcul:
		//  initLed.i = initLed.i / 2
		FCL_I = FCL_I / 2;
		

	}


}

void FCM_showLevel(char FCL_LEVEL)
{
	
	//Définitions des variables locales
	char FCL_BATLEVEL;

	//Décision
	//Décision: showLevel.level > 0?
	if (FCL_LEVEL > 0)
	{
		//Sortie
		//Sortie: 1 -> D0
		trisd = trisd & 0xfe;
		if (1)
			portd = (portd & 0xfe) | 0x01;
		else
			portd = portd & 0xfe;


	} else {
		//Sortie
		//Sortie: 0 -> D0
		trisd = trisd & 0xfe;
		if (0)
			portd = (portd & 0xfe) | 0x01;
		else
			portd = portd & 0xfe;


	}


	//Décision
	//Décision: showLevel.level > 36?
	if (FCL_LEVEL > 36)
	{
		//Sortie
		//Sortie: 1 -> D1
		trisd = trisd & 0xfd;
		if (1)
			portd = (portd & 0xfd) | 0x02;
		else
			portd = portd & 0xfd;


	} else {
		//Sortie
		//Sortie: 0 -> D1
		trisd = trisd & 0xfd;
		if (0)
			portd = (portd & 0xfd) | 0x02;
		else
			portd = portd & 0xfd;


	}


	//Décision
	//Décision: showLevel.level > 72?
	if (FCL_LEVEL > 72)
	{
		//Sortie
		//Sortie: 1 -> D2
		trisd = trisd & 0xfb;
		if (1)
			portd = (portd & 0xfb) | 0x04;
		else
			portd = portd & 0xfb;


	} else {
		//Sortie
		//Sortie: 0 -> D2
		trisd = trisd & 0xfb;
		if (0)
			portd = (portd & 0xfb) | 0x04;
		else
			portd = portd & 0xfb;


	}


	//Décision
	//Décision: showLevel.level > 108?
	if (FCL_LEVEL > 108)
	{
		//Sortie
		//Sortie: 1 -> D3
		trisd = trisd & 0xf7;
		if (1)
			portd = (portd & 0xf7) | 0x08;
		else
			portd = portd & 0xf7;


	} else {
		//Sortie
		//Sortie: 0 -> D3
		trisd = trisd & 0xf7;
		if (0)
			portd = (portd & 0xf7) | 0x08;
		else
			portd = portd & 0xf7;


	}


	//Décision
	//Décision: showLevel.level > 145?
	if (FCL_LEVEL > 145)
	{
		//Sortie
		//Sortie: 1 -> D4
		trisd = trisd & 0xef;
		if (1)
			portd = (portd & 0xef) | 0x10;
		else
			portd = portd & 0xef;


	} else {
		//Sortie
		//Sortie: 0 -> D4
		trisd = trisd & 0xef;
		if (0)
			portd = (portd & 0xef) | 0x10;
		else
			portd = portd & 0xef;


	}


	//Décision
	//Décision: showLevel.level > 181?
	if (FCL_LEVEL > 181)
	{
		//Sortie
		//Sortie: 1 -> D5
		trisd = trisd & 0xdf;
		if (1)
			portd = (portd & 0xdf) | 0x20;
		else
			portd = portd & 0xdf;


	} else {
		//Sortie
		//Sortie: 0 -> D5
		trisd = trisd & 0xdf;
		if (0)
			portd = (portd & 0xdf) | 0x20;
		else
			portd = portd & 0xdf;


	}


	//Décision
	//Décision: showLevel.level > 217?
	if (FCL_LEVEL > 217)
	{
		//Sortie
		//Sortie: 1 -> D6
		trisd = trisd & 0xbf;
		if (1)
			portd = (portd & 0xbf) | 0x40;
		else
			portd = portd & 0xbf;


	} else {
		//Sortie
		//Sortie: 0 -> D6
		trisd = trisd & 0xbf;
		if (0)
			portd = (portd & 0xbf) | 0x40;
		else
			portd = portd & 0xbf;


	}


	//Décision
	//Décision: showLevel.level > 254?
	if (FCL_LEVEL > 254)
	{
		//Sortie
		//Sortie: 1 -> D7
		trisd = trisd & 0x7f;
		if (1)
			portd = (portd & 0x7f) | 0x80;
		else
			portd = portd & 0x7f;


	} else {
		//Sortie
		//Sortie: 0 -> D7
		trisd = trisd & 0x7f;
		if (0)
			portd = (portd & 0x7f) | 0x80;
		else
			portd = portd & 0x7f;


	}


}

char FCM_isBattLevelOK(char FCL_PRCT)
{
	
	//Définitions des variables locales
	char FCL_BATTLEVEL;

	char FCR_RETVAL;

	//Appel d'une Macro
	//Appel d'une Macro: isBattLevelOK.battLevel=getBat
	FCL_BATTLEVEL = FCM_getBat();


	//Décision
	//Décision: isBattLevelOK.battLevel >= isBattLevelOK.prct?
	if (FCL_BATTLEVEL >= FCL_PRCT)
	{
		//Calcul
		//Calcul:
		//  isBattLevelOK.Return = true
		FCR_RETVAL = FCV_TRUE;
		

	} else {
		//Calcul
		//Calcul:
		//  isBattLevelOK.Return = false
		FCR_RETVAL = FCV_FALSE;
		

	}


	return (FCR_RETVAL);
}

char FCM_getBat()
{
	
	char FCR_RETVAL;

	//Appel de la Routine Composant
	//Appel de la Routine Composant: getBat.Return=ADC(0)::Lire_comme_Octet
	FCR_RETVAL = FCD_ADC0_ReadAsByte();


	return (FCR_RETVAL);
}

char FCM_getTrou(short FCL_TIMEOUT)
{
	
	//Définitions des variables locales
	short FCL_T;
	char FCL_CAPT;

	char FCR_RETVAL;

	//Calcul
	//Calcul:
	//  getTrou.Return = false
	//  getTrou.t = 0
	FCR_RETVAL = FCV_FALSE;
	FCL_T = 0;
	

	//Boucle
	//Boucle: Tant que getTrou.t < getTrou.timeout && getTrou.Return == false
	while (1)
	{
		//Appel d'une Macro
		//Appel d'une Macro: getTrou.capt=getTrouState(1)
		FCL_CAPT = FCM_getTrouState(1);


		//Décision
		//Décision: getTrou.capt?
		if (FCL_CAPT)
		{
			//Calcul
			//Calcul:
			//  getTrou.Return = true
			FCR_RETVAL = FCV_TRUE;
			

		}


		//Appel d'une Macro
		//Appel d'une Macro: getTrou.capt=getTrouState(2)
		FCL_CAPT = FCM_getTrouState(2);


		//Décision
		//Décision: getTrou.capt?
		if (FCL_CAPT)
		{
			//Calcul
			//Calcul:
			//  getTrou.Return = true
			FCR_RETVAL = FCV_TRUE;
			

		}


		//Calcul
		//Calcul:
		//  getTrou.t = getTrou.t + 25
		FCL_T = FCL_T + 25;
		

		//Pause
		//Pause: 25 ms
		delay_ms(25);


		if ((FCL_T < FCL_TIMEOUT && FCR_RETVAL == FCV_FALSE) == 0) break;
	}


	return (FCR_RETVAL);
}

void FCM_move(short FCL_VITESSE, short FCL_SENS, short FCL_DEGRE)
{
	
	//Définitions des variables locales
	short FCL_VITMOTD;
	short FCL_VITMOTG;

	//Décision
	//Décision: move.vitesse == stop?
	if (FCL_VITESSE == FCV_STOP)
	{
		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::Disable(1)
		FCD_PWM0_Disable(1);


		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::Disable(2)
		FCD_PWM0_Disable(2);


		//Sortie
		//Sortie: 0 -> C0
		trisc = trisc & 0xfe;
		if (0)
			portc = (portc & 0xfe) | 0x01;
		else
			portc = portc & 0xfe;


		//Sortie
		//Sortie: 0 -> C7
		trisc = trisc & 0x7f;
		if (0)
			portc = (portc & 0x7f) | 0x80;
		else
			portc = portc & 0x7f;


	} else {
		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::Enable(1)
		FCD_PWM0_Enable(1);


		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::Enable(2)
		FCD_PWM0_Enable(2);


		//droit ?
		//Décision: move.degre == droit?
		if (FCL_DEGRE == FCV_DROIT)
		{
			//Décision
			//Décision: move.sens == avant?
			if (FCL_SENS == FCV_AVANT)
			{
				//Sortie
				//Sortie: 0 -> C0
				trisc = trisc & 0xfe;
				if (0)
					portc = (portc & 0xfe) | 0x01;
				else
					portc = portc & 0xfe;


				//Sortie
				//Sortie: 0 -> C7
				trisc = trisc & 0x7f;
				if (0)
					portc = (portc & 0x7f) | 0x80;
				else
					portc = portc & 0x7f;


				//Calcul
				//Calcul:
				//  move.vitMotG = move.vitesse
				//  move.vitMotD = move.vitesse
				FCL_VITMOTG = FCL_VITESSE;
				FCL_VITMOTD = FCL_VITESSE;
				

			} else {
				//Sortie
				//Sortie: 1 -> C0
				trisc = trisc & 0xfe;
				if (1)
					portc = (portc & 0xfe) | 0x01;
				else
					portc = portc & 0xfe;


				//Sortie
				//Sortie: 1 -> C7
				trisc = trisc & 0x7f;
				if (1)
					portc = (portc & 0x7f) | 0x80;
				else
					portc = portc & 0x7f;


				//Calcul
				//Calcul:
				//  move.vitMotG = 255 - move.vitesse
				//  move.vitMotD = 255 - move.vitesse
				FCL_VITMOTG = 255 - FCL_VITESSE;
				FCL_VITMOTD = 255 - FCL_VITESSE;
				

			}


		} else {
			//degre 45-90
			//Décision: move.degre > 45 && move.degre <= 90?
			if (FCL_DEGRE > 45 && FCL_DEGRE <= 90)
			{
				//Décision
				//Décision: move.sens == avant?
				if (FCL_SENS == FCV_AVANT)
				{
					//Sortie
					//Sortie: 1 -> C0
					trisc = trisc & 0xfe;
					if (1)
						portc = (portc & 0xfe) | 0x01;
					else
						portc = portc & 0xfe;


					//Sortie
					//Sortie: 0 -> C7
					trisc = trisc & 0x7f;
					if (0)
						portc = (portc & 0x7f) | 0x80;
					else
						portc = portc & 0x7f;


					//Calcul
					//Calcul:
					//  move.vitMotG = 255 - (move.vitesse * (move.degre-45))/45
					//  move.vitMotD = move.vitesse
					FCL_VITMOTG = 255 - (FCL_VITESSE * (FCL_DEGRE-45))/45;
					FCL_VITMOTD = FCL_VITESSE;
					

				} else {
					//Sortie
					//Sortie: 0 -> C0
					trisc = trisc & 0xfe;
					if (0)
						portc = (portc & 0xfe) | 0x01;
					else
						portc = portc & 0xfe;


					//Sortie
					//Sortie: 1 -> C7
					trisc = trisc & 0x7f;
					if (1)
						portc = (portc & 0x7f) | 0x80;
					else
						portc = portc & 0x7f;


					//Calcul
					//Calcul:
					//  move.vitMotG = (move.vitesse * (move.degre-45))/45
					//  move.vitMotD = 255 - move.vitesse
					FCL_VITMOTG = (FCL_VITESSE * (FCL_DEGRE-45))/45;
					FCL_VITMOTD = 255 - FCL_VITESSE;
					

				}


			} else {
				//degre 0-45
				//Décision: move.degre <= 45?
				if (FCL_DEGRE <= 45)
				{
					//Décision
					//Décision: move.sens == avant?
					if (FCL_SENS == FCV_AVANT)
					{
						//Sortie
						//Sortie: 0 -> C0
						trisc = trisc & 0xfe;
						if (0)
							portc = (portc & 0xfe) | 0x01;
						else
							portc = portc & 0xfe;


						//Sortie
						//Sortie: 0 -> C7
						trisc = trisc & 0x7f;
						if (0)
							portc = (portc & 0x7f) | 0x80;
						else
							portc = portc & 0x7f;


						//Calcul
						//Calcul:
						//  move.vitMotG = move.vitesse - (move.vitesse * move.degre)/45
						//  move.vitMotD = move.vitesse
						FCL_VITMOTG = FCL_VITESSE - (FCL_VITESSE * FCL_DEGRE)/45;
						FCL_VITMOTD = FCL_VITESSE;
						

					} else {
						//Sortie
						//Sortie: 0 -> C0
						trisc = trisc & 0xfe;
						if (0)
							portc = (portc & 0xfe) | 0x01;
						else
							portc = portc & 0xfe;


						//Sortie
						//Sortie: 1 -> C7
						trisc = trisc & 0x7f;
						if (1)
							portc = (portc & 0x7f) | 0x80;
						else
							portc = portc & 0x7f;


						//Calcul
						//Calcul:
						//  move.vitMotG = 255 - move.vitesse * (45 - move.degre)/45
						//  move.vitMotD = 255 - move.vitesse
						FCL_VITMOTG = 255 - FCL_VITESSE * (45 - FCL_DEGRE)/45;
						FCL_VITMOTD = 255 - FCL_VITESSE;
						

					}


				} else {
					//degre 165-210 => -90 - -45
					//Décision: move.degre >= 165 && move.degre < 210?
					if (FCL_DEGRE >= 165 && FCL_DEGRE < 210)
					{
						//Décision
						//Décision: move.sens == avant?
						if (FCL_SENS == FCV_AVANT)
						{
							//Sortie
							//Sortie: 0 -> C0
							trisc = trisc & 0xfe;
							if (0)
								portc = (portc & 0xfe) | 0x01;
							else
								portc = portc & 0xfe;


							//Sortie
							//Sortie: 1 -> C7
							trisc = trisc & 0x7f;
							if (1)
								portc = (portc & 0x7f) | 0x80;
							else
								portc = portc & 0x7f;


							//Calcul
							//Calcul:
							//  move.vitMotD = (move.vitesse * (move.degre - 165))/45
							//  move.vitMotG = move.vitesse
							FCL_VITMOTD = (FCL_VITESSE * (FCL_DEGRE - 165))/45;
							FCL_VITMOTG = FCL_VITESSE;
							

						} else {
							//Sortie
							//Sortie: 1 -> C0
							trisc = trisc & 0xfe;
							if (1)
								portc = (portc & 0xfe) | 0x01;
							else
								portc = portc & 0xfe;


							//Sortie
							//Sortie: 0 -> C7
							trisc = trisc & 0x7f;
							if (0)
								portc = (portc & 0x7f) | 0x80;
							else
								portc = portc & 0x7f;


							//Calcul
							//Calcul:
							//  move.vitMotD = 255 - move.vitesse * (45 + move.degre + 210)/45
							//  move.vitMotG = move.vitesse
							FCL_VITMOTD = 255 - FCL_VITESSE * (45 + FCL_DEGRE + 210)/45;
							FCL_VITMOTG = FCL_VITESSE;
							

						}


					} else {
						//degre 210-255 => -40 - 0
						//Décision: move.degre >= 210?
						if (FCL_DEGRE >= 210)
						{
							//Décision
							//Décision: move.sens == avant?
							if (FCL_SENS == FCV_AVANT)
							{
								//Sortie
								//Sortie: 0 -> C0
								trisc = trisc & 0xfe;
								if (0)
									portc = (portc & 0xfe) | 0x01;
								else
									portc = portc & 0xfe;


								//Sortie
								//Sortie: 0 -> C7
								trisc = trisc & 0x7f;
								if (0)
									portc = (portc & 0x7f) | 0x80;
								else
									portc = portc & 0x7f;


								//Calcul
								//Calcul:
								//  move.vitMotD = (move.vitesse * (move.degre - 210))/45
								//  move.vitMotG = move.vitesse
								FCL_VITMOTD = (FCL_VITESSE * (FCL_DEGRE - 210))/45;
								FCL_VITMOTG = FCL_VITESSE;
								

							} else {
								//Sortie
								//Sortie: 1 -> C0
								trisc = trisc & 0xfe;
								if (1)
									portc = (portc & 0xfe) | 0x01;
								else
									portc = portc & 0xfe;


								//Sortie
								//Sortie: 1 -> C7
								trisc = trisc & 0x7f;
								if (1)
									portc = (portc & 0x7f) | 0x80;
								else
									portc = portc & 0x7f;


								//Calcul
								//Calcul:
								//  move.vitMotD = 255 - move.vitesse * (45 + move.degre + 255)/45
								//  move.vitMotG = move.vitesse
								FCL_VITMOTD = 255 - FCL_VITESSE * (45 + FCL_DEGRE + 255)/45;
								FCL_VITMOTG = FCL_VITESSE;
								

							}


						}


					}


				}


			}


		}


		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::SetDutyCycle(1, move.vitMotG)
		FCD_PWM0_SetDutyCycle(1, FCL_VITMOTG);


		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::SetDutyCycle(2, move.vitMotD)
		FCD_PWM0_SetDutyCycle(2, FCL_VITMOTD);


	}


}

void FCM_align()
{
	
	//Définitions des variables locales
	char FCL_ETAT;

	//Entrée
	//Entrée: PORTB -> align.etat
	trisb = trisb | 0x0c;
	FCL_ETAT = portb & 0x0c;


	//Boucle
	//Boucle: Tant que align.etat == 12
	while (!(FCL_ETAT == 12))
	{
		//Appel d'une Macro
		//Appel d'une Macro: align.etat=getTrouState(0)
		FCL_ETAT = FCM_getTrouState(0);


		//Multi-Décision
		//Multi-Décision: align.etat?
		switch (FCL_ETAT)
		{
			case 4:
			{
				//Right
				//Appel d'une Macro: move(64, avant, 45)
				FCM_move(64, FCV_AVANT, 45);


				break;
			}

			case 8:
			{
				//Left
				//Appel d'une Macro: move(64, avant, -45)
				FCM_move(64, FCV_AVANT, -45);


				break;
			}

		}


	}


	//Appel d'une Macro
	//Appel d'une Macro: move(stop, avant, droit)
	FCM_move(FCV_STOP, FCV_AVANT, FCV_DROIT);


	//Boucle
	//Boucle: Tant que align.etat == 0
	while (!(FCL_ETAT == 0))
	{
		//Entrée
		//Entrée: PORTB -> align.etat
		trisb = trisb | 0x0c;
		FCL_ETAT = portb & 0x0c;


		//Multi-Décision
		//Multi-Décision: align.etat?
		switch (FCL_ETAT)
		{
			case 4:
			{
				//Left
				//Appel d'une Macro: move(64, arriere, -45)
				FCM_move(64, FCV_ARRIERE, -45);


				break;
			}

			case 8:
			{
				//Right
				//Appel d'une Macro: move(64, arriere, 45)
				FCM_move(64, FCV_ARRIERE, 45);


				break;
			}

			case 12:
			{
				//Droit
				//Appel d'une Macro: move(64, arriere, droit)
				FCM_move(64, FCV_ARRIERE, FCV_DROIT);


				break;
			}

		}


	}


	//Appel d'une Macro
	//Appel d'une Macro: move(stop, avant, droit)
	FCM_move(FCV_STOP, FCV_AVANT, FCV_DROIT);


}

void FCM_verrin(char FCL_MONTE)
{
	
	//Décision
	//Décision: verrin.monte?
	if (FCL_MONTE)
	{
		//Sortie
		//Sortie: 0 -> A4
		trisa = trisa & 0xef;
		if (0)
			porta = (porta & 0xef) | 0x10;
		else
			porta = porta & 0xef;


		//Sortie
		//Sortie: 1 -> A5
		trisa = trisa & 0xdf;
		if (1)
			porta = (porta & 0xdf) | 0x20;
		else
			porta = porta & 0xdf;


	} else {
		//Sortie
		//Sortie: 1 -> A4
		trisa = trisa & 0xef;
		if (1)
			porta = (porta & 0xef) | 0x10;
		else
			porta = porta & 0xef;


		//Sortie
		//Sortie: 0 -> A5
		trisa = trisa & 0xdf;
		if (0)
			porta = (porta & 0xdf) | 0x20;
		else
			porta = porta & 0xdf;


	}


	//Pause
	//Pause: 5 s
	delay_s(5);


	//Sortie
	//Sortie: 0 -> A4
	trisa = trisa & 0xef;
	if (0)
		porta = (porta & 0xef) | 0x10;
	else
		porta = porta & 0xef;


	//Sortie
	//Sortie: 0 -> A5
	trisa = trisa & 0xdf;
	if (0)
		porta = (porta & 0xdf) | 0x20;
	else
		porta = porta & 0xdf;


}

char FCM_getTrouState(char FCL_NB)
{
	
	//Définitions des variables locales
	char FCL_VAL;
	char FCL_TRIG;

	char FCR_RETVAL;

	//Calcul
	//Calcul:
	//  getTrouState.trig = 225
	FCL_TRIG = 225;
	

	//Décision
	//Décision: getTrouState.val == 0?
	if (FCL_VAL == 0)
	{
		//Calcul
		//Calcul:
		//  getTrouState.Return = 0
		FCR_RETVAL = 0;
		

		//Lire ADC2
		//Appel de la Routine Composant: getTrouState.val=ADC(2)::Lire_comme_Octet
		FCL_VAL = FCD_ADC2_ReadAsByte();


		//Décision
		//Décision: getTrouState.val >= getTrouState.trig?
		if (FCL_VAL >= FCL_TRIG)
		{
			//Calcul
			//Calcul:
			//  getTrouState.Return = true
			FCR_RETVAL = FCV_TRUE;
			

		} else {
			//Calcul
			//Calcul:
			//  getTrouState.Return = false
			FCR_RETVAL = FCV_FALSE;
			

		}


		//Calcul
		//Calcul:
		//  getTrouState.Return = getTrouState.Return << 1
		FCR_RETVAL = FCR_RETVAL << 1;
		

		//Lire ADC2
		//Appel de la Routine Composant: getTrouState.val=ADC(3)::Lire_comme_Octet
		FCL_VAL = FCD_ADC3_ReadAsByte();


		//Décision
		//Décision: getTrouState.val >= getTrouState.trig?
		if (FCL_VAL >= FCL_TRIG)
		{
			//Calcul
			//Calcul:
			//  getTrouState.Return = getTrouState.Return | true
			FCR_RETVAL = FCR_RETVAL | FCV_TRUE;
			

		} else {
			//Calcul
			//Calcul:
			//  getTrouState.Return = getTrouState.Return | false
			FCR_RETVAL = FCR_RETVAL | FCV_FALSE;
			

		}


		//Calcul
		//Calcul:
		//  getTrouState.Return = getTrouState.Return >> 1
		FCR_RETVAL = FCR_RETVAL >> 1;
		

	} else {
		//Multi-Décision
		//Multi-Décision: getTrouState.nb?
		switch (FCL_NB)
		{
			case 1:
			{
				//Lire ADC2
				//Appel de la Routine Composant: getTrouState.val=ADC(2)::Lire_comme_Octet
				FCL_VAL = FCD_ADC2_ReadAsByte();


				break;
			}

			case 2:
			{
				//Lire ADC3
				//Appel de la Routine Composant: getTrouState.val=ADC(3)::Lire_comme_Octet
				FCL_VAL = FCD_ADC3_ReadAsByte();


				break;
			}

		}


		//Décision
		//Décision: getTrouState.val >= getTrouState.trig?
		if (FCL_VAL >= FCL_TRIG)
		{
			//Calcul
			//Calcul:
			//  getTrouState.Return = true
			FCR_RETVAL = FCV_TRUE;
			

		} else {
			//Calcul
			//Calcul:
			//  getTrouState.Return = false
			FCR_RETVAL = FCV_FALSE;
			

		}


	}


	return (FCR_RETVAL);
}

//Implémentations supplémentaires


void main()
{
	
	//Initialisation
	adcon1 = 0x0F;
	ucfg = 0x08;
cr_bit(pie2, USBIE);


	//Code d'initialisation d'Interruption
	


	//Calcul
	//Calcul:
	//  true = 1
	//  false = 0
	//  stop = 0
	//  avant = 1
	//  arriere = 2
	//  droit = 0
	//  left = -90
	//  right = 90
	FCV_TRUE = 1;
	FCV_FALSE = 0;
	FCV_STOP = 0;
	FCV_AVANT = 1;
	FCV_ARRIERE = 2;
	FCV_DROIT = 0;
	FCV_LEFT = -90;
	FCV_RIGHT = 90;
	

	//Décision
	//Décision: true?
	if (FCV_TRUE)
	{
		//Appel de la Routine Composant
		//Appel de la Routine Composant: Stepper(0)::EnableMotor
		FCD_Stepper0_EnableMotor();


		//Boucle
		//Boucle: Tant que 1
		while (1)
		{
			//Appel de la Routine Composant
			//Appel de la Routine Composant: Stepper(0)::IncrementStep
			FCD_Stepper0_IncrementStep();


			//Pause
			//Pause: 25 ms
			delay_ms(25);


		}


	} else {
		//Boucle
		//Boucle: Tant que 1
		while (1)
		{
			//Appel d'une Macro
			//Appel d'une Macro: getTrouState(0)
			FCM_getTrouState(0);


		}


	}


	//Appel d'une Macro
	//Appel d'une Macro: initLed
	FCM_initLed();


	//Boucle
	//Boucle: Tant que 1
	while (1)
	{
		//Appel d'une Macro
		//Appel d'une Macro: battLevelOk=getBat
		FCV_BATTLEVELOK = FCM_getBat();


		//Appel d'une Macro
		//Appel d'une Macro: showLevel(battLevelOk)
		FCM_showLevel(FCV_BATTLEVELOK);


		//Appel d'une Macro
		//Appel d'une Macro: battLevelOk=isBattLevelOK(127)
		FCV_BATTLEVELOK = FCM_isBattLevelOK(127);


		//Décision
		//Décision: battLevelOk?
		if (FCV_BATTLEVELOK)
		{
			//Commentaire:
			//C'est parti !!!


			//Appel d'une Macro
			//Appel d'une Macro: move(255, avant, droit)
			FCM_move(255, FCV_AVANT, FCV_DROIT);


			//Appel d'une Macro
			//Appel d'une Macro: isTrou=getTrou(1000)
			FCV_ISTROU = FCM_getTrou(1000);


			//Décision
			//Décision: isTrou?
			if (FCV_ISTROU)
			{
				//Commentaire:
				//Alignement


				//Appel d'une Macro
				//Appel d'une Macro: align
				FCM_align();


				//Commentaire:
				//Test trou !
				//(Longueur)


				//Commentaire:
				//On recule de 5cm : 
				//Pendant 1s a 0.035% de la vitesse max
				//0.035% => 9 / 255


				//Appel d'une Macro
				//Appel d'une Macro: move(9, arriere, droit)
				FCM_move(9, FCV_ARRIERE, FCV_DROIT);


				//Pause
				//Pause: 1 s
				delay_s(1);


				//Appel d'une Macro
				//Appel d'une Macro: move(stop, avant, droit)
				FCM_move(FCV_STOP, FCV_AVANT, FCV_DROIT);


				//Commentaire:
				//Pose verrins


				//Appel d'une Macro
				//Appel d'une Macro: verrin(false)
				FCM_verrin(FCV_FALSE);


				//Commentaire:
				//Début pose pont


				//Sortie
				//Sortie: 0 -> C6
				trisc = trisc & 0xbf;
				if (0)
					portc = (portc & 0xbf) | 0x40;
				else
					portc = portc & 0xbf;


				//Sortie
				//Sortie: 1 -> E2
				trise = trise & 0xfb;
				if (1)
					porte = (porte & 0xfb) | 0x04;
				else
					porte = porte & 0xfb;


				//Tempo demi pose pont
				//Pause: 15 s
				delay_s(15);


				//Commentaire:
				//Début dépliage pont


				//Sortie
				//Sortie: 0 -> E0
				trise = trise & 0xfe;
				if (0)
					porte = (porte & 0xfe) | 0x01;
				else
					porte = porte & 0xfe;


				//Sortie
				//Sortie: 1 -> E1
				trise = trise & 0xfd;
				if (1)
					porte = (porte & 0xfd) | 0x02;
				else
					porte = porte & 0xfd;


				//Commentaire:
				//Attente des FDC


				//Calcul
				//Calcul:
				//  i = 0
				FCV_I = 0;
				

				//Boucle
				//Boucle: Tant que i != 0b11
				while (FCV_I != 3)
				{
					//Entrée
					//Entrée: PORTB -> pB
					trisb = trisb | 0xff;
					FCV_PB = portb;


					//Décision
					//Décision: (pB & 0b100000) != 0?
					if ((FCV_PB & 32) != 0)
					{
						//Calcul
						//Calcul:
						//  i = i | 0b01
						FCV_I = FCV_I | 1;
						

						//Sortie
						//Sortie: 0 -> E1
						trise = trise & 0xfd;
						if (0)
							porte = (porte & 0xfd) | 0x02;
						else
							porte = porte & 0xfd;


					}


					//Décision
					//Décision: (pB & 0b10000000) != 0?
					if ((FCV_PB & 128) != 0)
					{
						//Calcul
						//Calcul:
						//  i = i | 0b10
						FCV_I = FCV_I | 2;
						

						//Sortie
						//Sortie: 0 -> E2
						trise = trise & 0xfb;
						if (0)
							porte = (porte & 0xfb) | 0x04;
						else
							porte = porte & 0xfb;


					}


				}


				//Commentaire:
				//Remonté verrins


				//Appel d'une Macro
				//Appel d'une Macro: verrin(true)
				FCM_verrin(FCV_TRUE);


				//Commentaire:
				//Recule (enlever la pince)


				//Appel d'une Macro
				//Appel d'une Macro: move(63, arriere, droit)
				FCM_move(63, FCV_ARRIERE, FCV_DROIT);


				//Pause
				//Pause: 3 s
				delay_s(3);


				//Commentaire:
				//Monter la pince


				//Sortie
				//Sortie: 0 -> C6
				trisc = trisc & 0xbf;
				if (0)
					portc = (portc & 0xbf) | 0x40;
				else
					portc = portc & 0xbf;


				//Sortie
				//Sortie: 1 -> E2
				trise = trise & 0xfb;
				if (1)
					porte = (porte & 0xfb) | 0x04;
				else
					porte = porte & 0xfb;


				//Pause
				//Pause: 3 s
				delay_s(3);


				//Sortie
				//Sortie: 0 -> E2
				trise = trise & 0xfb;
				if (0)
					porte = (porte & 0xfb) | 0x04;
				else
					porte = porte & 0xfb;


				//Commentaire:
				//Passage sur le pont
				//5km/h
				//5000m/h
				//1.388m/s
				//=> 1.5m
				//==> 1s à 100%


				//Appel d'une Macro
				//Appel d'une Macro: move(25, avant, droit)
				FCM_move(25, FCV_AVANT, FCV_DROIT);


				//Pause
				//Pause: 10 s
				delay_s(10);


				//Commentaire:
				//Demi - tour


				//Appel d'une Macro
				//Appel d'une Macro: move(25, avant, -90)
				FCM_move(25, FCV_AVANT, -90);


				//Pause
				//Pause: 10 s
				delay_s(10);


				//Commentaire:
				//Baisser la pince


				//Sortie
				//Sortie: 1 -> C6
				trisc = trisc & 0xbf;
				if (1)
					portc = (portc & 0xbf) | 0x40;
				else
					portc = portc & 0xbf;


				//Sortie
				//Sortie: 0 -> E2
				trise = trise & 0xfb;
				if (0)
					porte = (porte & 0xfb) | 0x04;
				else
					porte = porte & 0xfb;


				//Boucle
				//Boucle: Tant que pB
				while (!(FCV_PB))
				{
					//Entrée
					//Entrée: B7 -> pB
					trisb = trisb | 0x80;
					FCV_PB = ((portb & 0x80) == 0x80);


				}


				//Sortie
				//Sortie: 0 -> C6
				trisc = trisc & 0xbf;
				if (0)
					portc = (portc & 0xbf) | 0x40;
				else
					portc = portc & 0xbf;


				//Commentaire:
				//Prise pont


				//Appel d'une Macro
				//Appel d'une Macro: move(127, avant, droit)
				FCM_move(127, FCV_AVANT, FCV_DROIT);


				//Pause
				//Pause: 5 s
				delay_s(5);


				//Commentaire:
				//Début prise pont


				//Sortie
				//Sortie: 1 -> C6
				trisc = trisc & 0xbf;
				if (1)
					portc = (portc & 0xbf) | 0x40;
				else
					portc = portc & 0xbf;


				//Sortie
				//Sortie: 0 -> E2
				trise = trise & 0xfb;
				if (0)
					porte = (porte & 0xfb) | 0x04;
				else
					porte = porte & 0xfb;


				//Tempo demi pose pont
				//Pause: 15 s
				delay_s(15);


				//Commentaire:
				//Début pliage pont


				//Sortie
				//Sortie: 1 -> E0
				trise = trise & 0xfe;
				if (1)
					porte = (porte & 0xfe) | 0x01;
				else
					porte = porte & 0xfe;


				//Sortie
				//Sortie: 0 -> E1
				trise = trise & 0xfd;
				if (0)
					porte = (porte & 0xfd) | 0x02;
				else
					porte = porte & 0xfd;


				//Commentaire:
				//Attente des FDC


				//Calcul
				//Calcul:
				//  i = 0
				FCV_I = 0;
				

				//Boucle
				//Boucle: Tant que i != 0b11
				while (FCV_I != 3)
				{
					//Entrée
					//Entrée: PORTB -> pB
					trisb = trisb | 0xff;
					FCV_PB = portb;


					//Décision
					//Décision: (pB & 0b10000) != 0?
					if ((FCV_PB & 16) != 0)
					{
						//Calcul
						//Calcul:
						//  i = i | 0b01
						FCV_I = FCV_I | 1;
						

						//Sortie
						//Sortie: 0 -> E0
						trise = trise & 0xfe;
						if (0)
							porte = (porte & 0xfe) | 0x01;
						else
							porte = porte & 0xfe;


					}


					//Décision
					//Décision: (pB & 0b1000000) != 0?
					if ((FCV_PB & 64) != 0)
					{
						//Calcul
						//Calcul:
						//  i = i | 0b10
						FCV_I = FCV_I | 2;
						

						//Sortie
						//Sortie: 0 -> C6
						trisc = trisc & 0xbf;
						if (0)
							portc = (portc & 0xbf) | 0x40;
						else
							portc = portc & 0xbf;


					}


				}


				//Commentaire:
				//Demi - tour


				//Appel d'une Macro
				//Appel d'une Macro: move(25, avant, -90)
				FCM_move(25, FCV_AVANT, -90);


				//Pause
				//Pause: 10 s
				delay_s(10);


			}


		} else {
			//Commentaire:
			//Nope :(


			//Appel d'une Macro
			//Appel d'une Macro: move(stop, 0, 0)
			FCM_move(FCV_STOP, 0, 0);


			//Pause
			//Pause: 500 ms
			delay_ms(255);
			delay_ms(245);


			//Appel d'une Macro
			//Appel d'une Macro: showLevel(0)
			FCM_showLevel(0);


			//Pause
			//Pause: 500 ms
			delay_ms(255);
			delay_ms(245);


		}


	}


	mainendloop: goto mainendloop;
}

void MX_INTERRUPT_MACRO(void)
{
}



