;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Full License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited, Non commercial use only
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     P:\SI\Projet\FlowCode\BattLevel.c
//**  Generated by:  Flowcode v4.5.18.74
//**  Date:          Friday, January 16, 2015 10:00:58
//**  Licence:       10 User
//**  Registered to: LYCEE-STMARC38-02
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL 
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Définir pour microcontrôleur
#define P18F4455
#define MX_EE
#define MX_EE_TYPE3
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_BCB
#define MX_SPI_SDI 0
#define MX_SPI_SDO 7
#define MX_SPI_SCK 1
#define MX_UART
#define MX_UART_C
#define MX_UART_TX 6
#define MX_UART_RX 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_B
#define MX_I2C_SDA 0
#define MX_I2C_SCL 1
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 2
#define MX_PWM_TRIS2 trisc
#define MX_PWM_2 1
#define MX_PWM_TRIS2a trisb
#define MX_PWM_2a 3
#define MX_USB_TYPE1

//Fonctions
#define MX_CLK_SPEED 48000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic18.h>
#endif

//Données de Configuration
#ifdef _BOOSTC
#pragma DATA 0x300000, 0x20
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0xe
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0x3e
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0x1e
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x81
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0x81
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0x80
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xa0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif

//Fonctions internes
#include "C:\Program Files\Matrix Multimedia\Flowcode V4\FCD\internals.h"

//Déclarations de fonction Macro
void FCM_initLed();
void FCM_showBattLevel();
char FCM_isBattLevelOK(char FCL_PRCT);
char FCM_getBat();
char FCM_getTrou(short FCL_TIMEOUT);


//Déclarations de Variable
char FCV_ISTROU;
char FCV_BATTLEVELOK;
char FCV_FALSE;
char FCV_TRUE;

char FCLV_LOOP1;
char FCLV_LOOP2;



//ADC(0): //Defines:

/**** Macro Substitutions ****
0 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
0 = VRef+ Option
500 = VRef Voltage x 0.01V
0 = MIAC System ordinal
0 = MIAC System module type
******************************/




//ADC(0): //Déclarations de fonction Macro

void FCD_ADC0_SampleADC();
char FCD_ADC0_ReadAsByte();
short FCD_ADC0_ReadAsInt();
float FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);


//PWM(0): //Defines:

/**** Macro Substitutions ****
255 = Timer 2 Rollover Value
0x04 = Timer 2 Prescaler Value
-1 = MIAC System ID
0 = Alternate Pin FCD_PWM0_Enable
******************************/




//PWM(0): //Déclarations de fonction Macro

void FCD_PWM0_Enable(char nIdx);
void FCD_PWM0_Disable(char nIdx);
void FCD_PWM0_SetDutyCycle(char nIdx, char nDuty);
void FCD_PWM0_ChangePeriod(char nPeriodVal, char nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(char nIdx, short nDuty);



//ADC(0): //Implémentations Macro


void FCD_ADC0_SampleADC()

{
	
	/*******Supported Devices******************************************************************
	// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
	// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
	// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
	// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
	// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
	// 18F4680, 18F4682, 18F4685
	******************************************************************************************/

	#ifndef MX_MIAC

		#define MX_ADC_CHANNEL		0
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		0

		//set up ADC conversion
		char old_tris, cnt;
		adcon2 = MX_ADC_CONV_SP & 0x07;
08B6  0E03      	MOVLW 0x03
08B8  6EC0      	MOVWF gbl_adcon2


		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x0E;
08BA  0E0E      	MOVLW 0x0E
08BC  6EC1      	MOVWF gbl_adcon1

		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x0D;
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x0C;
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x08
			adcon1 = 0x0B;
			#if (MX_ADC_VREF_OPT != 0)
				#error "Target device is currently using AN3 for VREF+"
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x20
			adcon1 = 0x0A;
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x09;
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x08;
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x07;
		#endif
		#if (MX_ADC_CHANNEL == 8)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x06;
		#endif
		#if (MX_ADC_CHANNEL == 9)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x05;
		#endif
		#if (MX_ADC_CHANNEL == 10)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x04;
		#endif
		#if (MX_ADC_CHANNEL == 11)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x03;
		#endif
		#if (MX_ADC_CHANNEL == 12)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x02;
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#error "ADC Type 13 conversion code error - please contact technical support"
		#endif

		//assign VREF functionality
		#if (MX_ADC_VREF_OPT != 0)
			st_bit(adcon1, VCFG0);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
08BE  5092      	MOVF gbl_trisa, W
08C0  6E2E      	MOVWF FCD_ADC0_S_00042_1_old_tris

		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;
08C2  0E01      	MOVLW 0x01
08C4  1092      	IORWF gbl_trisa, W
08C6  6E92      	MOVWF gbl_trisa


		//turn ADC on
		adcon0 = 0x01 | (MX_ADC_CHANNEL << 2);
08C8  0E01      	MOVLW 0x01
08CA  6EC2      	MOVWF gbl_adcon0


		//wait the acquisition time
		cnt = 0;
08CC  6A2F      	CLRF FCD_ADC0_S_00042_1_cnt

		while (cnt < MX_ADC_SAMP_TIME) cnt++;
08CE            label4
08CE  0E28      	MOVLW 0x28
08D0  602F      	CPFSLT FCD_ADC0_S_00042_1_cnt
08D2  D002      	BRA	label5
08D4  2A2F      	INCF FCD_ADC0_S_00042_1_cnt, F
08D6  D7FB      	BRA	label4
08D8            label5


		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x02;
08D8  0E02      	MOVLW 0x02
08DA  10C2      	IORWF gbl_adcon0, W
08DC  6EC2      	MOVWF gbl_adcon0

		while (adcon0 & 0x02);
08DE            label6
08DE  B2C2      	BTFSC gbl_adcon0,1
08E0  D7FE      	BRA	label6


		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
08E2  502E      	MOVF FCD_ADC0_S_00042_1_old_tris, W
08E4  6E92      	MOVWF gbl_trisa

		adcon1 = 0x0f;
08E6  0E0F      	MOVLW 0x0F
08E8  6EC1      	MOVWF gbl_adcon1

		adcon0 = 0x00;
08EA  6AC2      	CLRF gbl_adcon0


		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CHANNEL
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

	#endif

}
08EC  0012      	RETURN


char FCD_ADC0_ReadAsByte()

{
	
	#ifdef MX_MIAC_SYSTEM
		int iSample;

		iSample = FCD_ADC0_ReadAsInt();

		return (iSample >> 2);
	#else

		FCD_ADC0_SampleADC();
08EE  EC5BF004  	CALL FCD_ADC0_S_00042


		return adresh;
08F2  50C4      	MOVF gbl_adresh, W
08F4  6E2E      	MOVWF CompTempVarRet2193

	#endif

}
08F6  0012      	RETURN


short FCD_ADC0_ReadAsInt()
{
	
		short iRetVal;

	#ifdef MX_MIAC_SYSTEM

	  #if (0 == MX_MIAC_MM_MIAC_BASE)
	  	iRetVal = MIAC_Master_InputANA10(0);
	  #else
		unsigned int ModID = ((0 << 5) + 0) << 9;

		MIAC_CAN_TX[0] = 0;

		MIAC_Module_WR(ModID, 289, 1,1,0);
		MIAC_Module_GetAck(ModID + 32, 289, 200);
		iRetVal = ((MIAC_CAN_RX[0] << 8) | MIAC_CAN_RX[1]) >> 2;
	  #endif
	#else
		FCD_ADC0_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);
	#endif
		return (iRetVal);

}

float FCD_ADC0_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC0_ReadAsInt();											//Read as 10-bit Integer

		fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
		fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
		fSample = float32_from_int32(iSample);							//Convert to floating point variable
		fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//PWM(0): //Implémentations Macro


void FCD_PWM0_Enable(char nIdx)

{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif

	#ifdef MX_MIAC_EXTERNAL
		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[1] = 255;
		MIAC_CAN_TX[2] = 0x04;
		MIAC_Module_WR(ModID, 320, 3, 1, 0);
		MIAC_Module_GetAck(ModID + 32, 320, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  #ifndef MX_PWM		//error checking
		#error "This chip does not have PWM capability"
	  #else
		#ifndef MX_PWM_CNT
			#error "FCD file error (no MX_PWM_CNT)"
		#endif
		#if (MX_PWM_CNT < 1)
			#error "FCD file error (MX_PWM_CNT < 1)"
		#endif
		//#if (MX_PWM_CNT > 2)
		//	#error "FCD file error (MX_PWM_CNT > 2)"
		//#endif
		#ifndef MX_PWM_TRIS1
			#error "FCD file error (no MX_PWM_TRIS1)"
		#endif
		#ifndef MX_PWM_1
			#error "FCD file error (no MX_PWM_1)"
		#endif
	    #if (MX_PWM_CNT == 2)
	      	#ifndef MX_PWM_TRIS2
				#error "FCD file error (no MX_PWM_TRIS2)"
	      	#endif
	      	#ifndef MX_PWM_2
				#error "FCD file error (no MX_PWM_2)"
	      	#endif
	    #endif
	    #if (0 == 1)
	      	#ifndef MX_PWM_TRIS1a
				#error "PWM component error (using alternative, but no MX_PWM_TRIS1a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	      	#ifndef MX_PWM_1a
				#error "PWM component error (using alternative, but no MX_PWM_1a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	    #endif
	    #if (0 == 2)
	      	#ifndef MX_PWM_TRIS2a
				#error "PWM component error (using alternative, but no MX_PWM_TRIS2a)"
	  			#define MX_PWM_ALT_ERROR
	      	#endif
	      	#ifndef MX_PWM_2a
				#error "PWM component error (using alternative, but no MX_PWM_2a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	    #endif

	 	#ifdef MX_PWM
			pr2 = 255;
0B3C  68CB      	SETF gbl_pr2

			t2con = 0x04;
0B3E  0E04      	MOVLW 0x04
0B40  6ECA      	MOVWF gbl_t2con

		#endif

	  	#if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
0B42  042A      	DECF FCD_PWM0_E_00047_arg_nIdx, W
0B44  E103      	BNZ	label34
0B4C            label34

			{
				ccp1con = 0x0C;
0B46  0E0C      	MOVLW 0x0C
0B48  6EBD      	MOVWF gbl_ccp1con


			  	#if (0 == 1)
			   		#ifndef MX_PWM_ALT_ERROR
						clear_bit(MX_PWM_TRIS1a, MX_PWM_1a);
			   		#endif
			  	#else
					clear_bit(MX_PWM_TRIS1, MX_PWM_1);
0B4A  9494      	BCF gbl_trisc,2

			  	#endif
			}
	  	#endif

	  	#if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
0B4C  0E02      	MOVLW 0x02
0B4E  622A      	CPFSEQ FCD_PWM0_E_00047_arg_nIdx

			{
				ccp2con = 0x0C;
0B52  0E0C      	MOVLW 0x0C
0B54  6EBA      	MOVWF gbl_ccp2con

			  	#if (0 == 2)
			   		#ifndef MX_PWM_ALT_ERROR
						clear_bit(MX_PWM_TRIS2a, MX_PWM_2a);
			   		#endif
			 	#else
					clear_bit(MX_PWM_TRIS2, MX_PWM_2);
0B56  9294      	BCF gbl_trisc,1

			  	#endif
		   }
	  	#endif
	  #endif

	  #ifdef MX_PWM_ALT_ERROR
	   #undef MX_PWM_ALT_ERROR
	  #endif

	#endif

}
0B50  0012      	RETURN
0B58  0012      	RETURN


void FCD_PWM0_Disable(char nIdx)

{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL
		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_Module_WR(ModID, 321, 1, 1, 0);
		MIAC_Module_GetAck(ModID, 321, 20);

		#undef MX_MIAC_EXTERNAL

	#else

	 	#ifndef MX_PWM		//error checking
			#error "This chip does not have PWM capability"
	  	#else
		  	#if (MX_PWM_CNT >= 1)
				if (nIdx == 1)
0B5A  042A      	DECF FCD_PWM0_D_00048_arg_nIdx, W
0B5C  B4D8      	BTFSC STATUS,Z

				{
					ccp1con = 0x00;
0B5E  6ABD      	CLRF gbl_ccp1con

				}
		  	#endif

		  	#if (MX_PWM_CNT >= 2)
				if (nIdx == 2)
0B60  0E02      	MOVLW 0x02
0B62  622A      	CPFSEQ FCD_PWM0_D_00048_arg_nIdx

				{
					ccp2con = 0x00;
0B66  6ABA      	CLRF gbl_ccp2con

				}
		  	#endif
	 	#endif
	#endif

}
0B64  0012      	RETURN
0B68  0012      	RETURN


void FCD_PWM0_SetDutyCycle(char nIdx, char nDuty)

{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif

	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[1] = nDuty;
		MIAC_Module_WR(ModID, 322, 2, 1, 0);
		MIAC_Module_GetAck(ModID, 322, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  //error checking
	  #ifndef MX_PWM
		#error "This chip does not have PWM capability"
	  #else
		  #if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
0B28  042A      	DECF FCD_PWM0_S_00049_arg_nIdx, W
0B2A  E102      	BNZ	label33
0B30            label33

			{
				ccpr1l = nDuty;
0B2C  502B      	MOVF FCD_PWM0_S_00049_arg_nDuty, W
0B2E  6EBE      	MOVWF gbl_ccpr1l

			}
		  #endif

		  #if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
0B30  0E02      	MOVLW 0x02
0B32  622A      	CPFSEQ FCD_PWM0_S_00049_arg_nIdx

			{
				ccpr2l = nDuty;
0B36  502B      	MOVF FCD_PWM0_S_00049_arg_nDuty, W
0B38  6EBB      	MOVWF gbl_ccpr2l

			}
		  #endif
	 #endif
	#endif

}
0B34  0012      	RETURN
0B3A  0012      	RETURN


void FCD_PWM0_ChangePeriod(char nPeriodVal, char nPrescalerVal)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nPeriodVal;
		MIAC_CAN_TX[1] = nPrescalerVal;
		MIAC_CAN_TX[2] = (nPrescalerVal >> 8);
		MIAC_Module_WR(ModID, 323, 3, 1, 0);
		MIAC_Module_GetAck(ModID, 323, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  //error checking
	  #ifndef MX_PWM
			#error "This chip does not have PWM capability"
	  #else
	    pr2 = nPeriodVal;

	    switch (nPrescalerVal)
	    {
	        case 1:
	            t2con = 0x04;
	            break;

	        case 4:
	            t2con = 0x05;
	            break;

	        case 16:
	            t2con = 0x06;
	            break;
	    }
	  #endif
	#endif

}

void FCD_PWM0_SetDutyCycle10bit(char nIdx, short nDuty)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[2] = nDuty;
		MIAC_CAN_TX[1] = (nDuty >> 8);
		MIAC_Module_WR(ModID, 324, 3, 1, 0);
		MIAC_Module_GetAck(ModID, 324, 20);

		#undef MX_MIAC_EXTERNAL
	#else

		char nCCPxCONtemp;

	  //error checking
	  #ifndef MX_PWM
	  	#error "This chip does not have PWM capability"
	  #else
		  #if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccpr1l = (nDuty & 0x3FC) >> 2;

				nDuty = (nDuty & 0x03) << 4;
				nCCPxCONtemp = (ccp1con & 0xCF) | nDuty;
				ccp1con = nCCPxCONtemp;
			}
		  #endif

		  #if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccpr2l = (nDuty & 0x3FC) >> 2;

				nDuty = (nDuty & 0x03) << 4;
				nCCPxCONtemp = (ccp2con & 0xCF) | nDuty;
				ccp2con = nCCPxCONtemp;
			}
		  #endif
	 #endif
	#endif

}

//Implémentations Macro

void FCM_initLed()

{
	
	//Définitions des variables locales
	char FCL_I;

	//Calcul
	//Calcul:
	//  initLed.i = 1
	FCL_I = 1;
0A60  0E01      	MOVLW 0x01
0A62  6E2A      	MOVWF FCM_initLe_0003D_1_FCL_I

	

	//Boucle
	//Boucle: Boucle 8 fois
	for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
0A64  6A28      	CLRF gbl_FCLV_LOOP1
0A66            label25
0A66  0E08      	MOVLW 0x08
0A68  6028      	CPFSLT gbl_FCLV_LOOP1
0A6A  D00E      	BRA	label26
0A84  2A28      	INCF gbl_FCLV_LOOP1, F
0A86  D7EF      	BRA	label25
0A88            label26

	{
		//Sortie
		//Sortie: initLed.i -> PORTD
		trisd = 0x00;
0A6C  6A95      	CLRF gbl_trisd

		portd = FCL_I;
0A6E  502A      	MOVF FCM_initLe_0003D_1_FCL_I, W
0A70  6E83      	MOVWF gbl_portd



		//Pause
		//Pause: 100 ms
		delay_ms(100);
0A72  0E64      	MOVLW 0x64
0A74  6E33      	MOVWF delay_ms_00000_arg_del
0A76  EC06F004  	CALL delay_ms_00000



		//Sortie
		//Sortie: 0 -> PORTD
		trisd = 0x00;
0A7A  6A95      	CLRF gbl_trisd

		portd = 0;
0A7C  6A83      	CLRF gbl_portd



		//Calcul
		//Calcul:
		//  initLed.i = initLed.i * 2
		FCL_I = FCL_I * 2;
0A7E  522A      	MOVF FCM_initLe_0003D_1_FCL_I, F
0A80  90D8      	BCF STATUS,C
0A82  362A      	RLCF FCM_initLe_0003D_1_FCL_I, F

		

	}


	//Calcul
	//Calcul:
	//  initLed.i = 128
	FCL_I = 128;
0A88  0E80      	MOVLW 0x80
0A8A  6E2A      	MOVWF FCM_initLe_0003D_1_FCL_I

	

	//Boucle
	//Boucle: Boucle 8 fois
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
0A8C  6A29      	CLRF gbl_FCLV_LOOP2
0A8E            label27
0A8E  0E08      	MOVLW 0x08
0A90  6029      	CPFSLT gbl_FCLV_LOOP2
0AAC  2A29      	INCF gbl_FCLV_LOOP2, F
0AAE  D7EF      	BRA	label27

	{
		//Sortie
		//Sortie: initLed.i -> PORTD
		trisd = 0x00;
0A94  6A95      	CLRF gbl_trisd

		portd = FCL_I;
0A96  502A      	MOVF FCM_initLe_0003D_1_FCL_I, W
0A98  6E83      	MOVWF gbl_portd



		//Pause
		//Pause: 100 ms
		delay_ms(100);
0A9A  0E64      	MOVLW 0x64
0A9C  6E33      	MOVWF delay_ms_00000_arg_del
0A9E  EC06F004  	CALL delay_ms_00000



		//Sortie
		//Sortie: 0 -> PORTD
		trisd = 0x00;
0AA2  6A95      	CLRF gbl_trisd

		portd = 0;
0AA4  6A83      	CLRF gbl_portd



		//Calcul
		//Calcul:
		//  initLed.i = initLed.i / 2
		FCL_I = FCL_I / 2;
0AA6  522A      	MOVF FCM_initLe_0003D_1_FCL_I, F
0AA8  90D8      	BCF STATUS,C
0AAA  322A      	RRCF FCM_initLe_0003D_1_FCL_I, F

		

	}


}
0A92  0012      	RETURN


void FCM_showBattLevel()

{
	
	//Définitions des variables locales
	char FCL_BATLEVEL;

	//Appel d'une Macro
	//Appel d'une Macro: showBattLevel.batLevel=getBat
	FCL_BATLEVEL = FCM_getBat();
0906  EC7CF004  	CALL FCM_getBat_00000
090A  502E      	MOVF CompTempVarRet2191, W
090C  6E2A      	MOVWF FCM_showBa_0003E_1_FCL_BATLEVEL



	//Décision
	//Décision: showBattLevel.batLevel > 0?
	if (FCL_BATLEVEL > 0)
090E  0E00      	MOVLW 0x00
0910  642A      	CPFSGT FCM_showBa_0003E_1_FCL_BATLEVEL
0912  D00A      	BRA	label7
0928            label7

	{
		//Sortie
		//Sortie: 1 -> D0
		trisd = trisd & 0xfe;
0914  0EFE      	MOVLW 0xFE
0916  1495      	ANDWF gbl_trisd, W
0918  6E95      	MOVWF gbl_trisd

		if (1)
			portd = (portd & 0xfe) | 0x01;
091A  0EFE      	MOVLW 0xFE
091C  1483      	ANDWF gbl_portd, W
091E  6E2B      	MOVWF CompTempVar2183
0920  0E01      	MOVLW 0x01
0922  102B      	IORWF CompTempVar2183, W
0924  6E83      	MOVWF gbl_portd

		else
			portd = portd & 0xfe;


	} else {
0926  D006      	BRA	label8
0934            label8

		//Sortie
		//Sortie: 0 -> D0
		trisd = trisd & 0xfe;
0928  0EFE      	MOVLW 0xFE
092A  1495      	ANDWF gbl_trisd, W
092C  6E95      	MOVWF gbl_trisd

		if (0)
			portd = (portd & 0xfe) | 0x01;
		else
			portd = portd & 0xfe;
092E  0EFE      	MOVLW 0xFE
0930  1483      	ANDWF gbl_portd, W
0932  6E83      	MOVWF gbl_portd



	}


	//Décision
	//Décision: showBattLevel.batLevel > 36?
	if (FCL_BATLEVEL > 36)
0934  0E24      	MOVLW 0x24
0936  642A      	CPFSGT FCM_showBa_0003E_1_FCL_BATLEVEL
0938  D00A      	BRA	label9
094E            label9

	{
		//Sortie
		//Sortie: 1 -> D1
		trisd = trisd & 0xfd;
093A  0EFD      	MOVLW 0xFD
093C  1495      	ANDWF gbl_trisd, W
093E  6E95      	MOVWF gbl_trisd

		if (1)
			portd = (portd & 0xfd) | 0x02;
0940  0EFD      	MOVLW 0xFD
0942  1483      	ANDWF gbl_portd, W
0944  6E2B      	MOVWF CompTempVar2184
0946  0E02      	MOVLW 0x02
0948  102B      	IORWF CompTempVar2184, W
094A  6E83      	MOVWF gbl_portd

		else
			portd = portd & 0xfd;


	} else {
094C  D006      	BRA	label10
095A            label10

		//Sortie
		//Sortie: 0 -> D1
		trisd = trisd & 0xfd;
094E  0EFD      	MOVLW 0xFD
0950  1495      	ANDWF gbl_trisd, W
0952  6E95      	MOVWF gbl_trisd

		if (0)
			portd = (portd & 0xfd) | 0x02;
		else
			portd = portd & 0xfd;
0954  0EFD      	MOVLW 0xFD
0956  1483      	ANDWF gbl_portd, W
0958  6E83      	MOVWF gbl_portd



	}


	//Décision
	//Décision: showBattLevel.batLevel > 72?
	if (FCL_BATLEVEL > 72)
095A  0E48      	MOVLW 0x48
095C  642A      	CPFSGT FCM_showBa_0003E_1_FCL_BATLEVEL
095E  D00A      	BRA	label11
0974            label11

	{
		//Sortie
		//Sortie: 1 -> D2
		trisd = trisd & 0xfb;
0960  0EFB      	MOVLW 0xFB
0962  1495      	ANDWF gbl_trisd, W
0964  6E95      	MOVWF gbl_trisd

		if (1)
			portd = (portd & 0xfb) | 0x04;
0966  0EFB      	MOVLW 0xFB
0968  1483      	ANDWF gbl_portd, W
096A  6E2B      	MOVWF CompTempVar2185
096C  0E04      	MOVLW 0x04
096E  102B      	IORWF CompTempVar2185, W
0970  6E83      	MOVWF gbl_portd

		else
			portd = portd & 0xfb;


	} else {
0972  D006      	BRA	label12
0980            label12

		//Sortie
		//Sortie: 0 -> D2
		trisd = trisd & 0xfb;
0974  0EFB      	MOVLW 0xFB
0976  1495      	ANDWF gbl_trisd, W
0978  6E95      	MOVWF gbl_trisd

		if (0)
			portd = (portd & 0xfb) | 0x04;
		else
			portd = portd & 0xfb;
097A  0EFB      	MOVLW 0xFB
097C  1483      	ANDWF gbl_portd, W
097E  6E83      	MOVWF gbl_portd



	}


	//Décision
	//Décision: showBattLevel.batLevel > 108?
	if (FCL_BATLEVEL > 108)
0980  0E6C      	MOVLW 0x6C
0982  642A      	CPFSGT FCM_showBa_0003E_1_FCL_BATLEVEL
0984  D00A      	BRA	label13
099A            label13

	{
		//Sortie
		//Sortie: 1 -> D3
		trisd = trisd & 0xf7;
0986  0EF7      	MOVLW 0xF7
0988  1495      	ANDWF gbl_trisd, W
098A  6E95      	MOVWF gbl_trisd

		if (1)
			portd = (portd & 0xf7) | 0x08;
098C  0EF7      	MOVLW 0xF7
098E  1483      	ANDWF gbl_portd, W
0990  6E2B      	MOVWF CompTempVar2186
0992  0E08      	MOVLW 0x08
0994  102B      	IORWF CompTempVar2186, W
0996  6E83      	MOVWF gbl_portd

		else
			portd = portd & 0xf7;


	} else {
0998  D006      	BRA	label14
09A6            label14

		//Sortie
		//Sortie: 0 -> D3
		trisd = trisd & 0xf7;
099A  0EF7      	MOVLW 0xF7
099C  1495      	ANDWF gbl_trisd, W
099E  6E95      	MOVWF gbl_trisd

		if (0)
			portd = (portd & 0xf7) | 0x08;
		else
			portd = portd & 0xf7;
09A0  0EF7      	MOVLW 0xF7
09A2  1483      	ANDWF gbl_portd, W
09A4  6E83      	MOVWF gbl_portd



	}


	//Décision
	//Décision: showBattLevel.batLevel > 145?
	if (FCL_BATLEVEL > 145)
09A6  0E91      	MOVLW 0x91
09A8  642A      	CPFSGT FCM_showBa_0003E_1_FCL_BATLEVEL
09AA  D00A      	BRA	label15
09C0            label15

	{
		//Sortie
		//Sortie: 1 -> D4
		trisd = trisd & 0xef;
09AC  0EEF      	MOVLW 0xEF
09AE  1495      	ANDWF gbl_trisd, W
09B0  6E95      	MOVWF gbl_trisd

		if (1)
			portd = (portd & 0xef) | 0x10;
09B2  0EEF      	MOVLW 0xEF
09B4  1483      	ANDWF gbl_portd, W
09B6  6E2B      	MOVWF CompTempVar2187
09B8  0E10      	MOVLW 0x10
09BA  102B      	IORWF CompTempVar2187, W
09BC  6E83      	MOVWF gbl_portd

		else
			portd = portd & 0xef;


	} else {
09BE  D006      	BRA	label16
09CC            label16

		//Sortie
		//Sortie: 0 -> D4
		trisd = trisd & 0xef;
09C0  0EEF      	MOVLW 0xEF
09C2  1495      	ANDWF gbl_trisd, W
09C4  6E95      	MOVWF gbl_trisd

		if (0)
			portd = (portd & 0xef) | 0x10;
		else
			portd = portd & 0xef;
09C6  0EEF      	MOVLW 0xEF
09C8  1483      	ANDWF gbl_portd, W
09CA  6E83      	MOVWF gbl_portd



	}


	//Décision
	//Décision: showBattLevel.batLevel > 181?
	if (FCL_BATLEVEL > 181)
09CC  0EB5      	MOVLW 0xB5
09CE  642A      	CPFSGT FCM_showBa_0003E_1_FCL_BATLEVEL
09D0  D00A      	BRA	label17
09E6            label17

	{
		//Sortie
		//Sortie: 1 -> D5
		trisd = trisd & 0xdf;
09D2  0EDF      	MOVLW 0xDF
09D4  1495      	ANDWF gbl_trisd, W
09D6  6E95      	MOVWF gbl_trisd

		if (1)
			portd = (portd & 0xdf) | 0x20;
09D8  0EDF      	MOVLW 0xDF
09DA  1483      	ANDWF gbl_portd, W
09DC  6E2B      	MOVWF CompTempVar2188
09DE  0E20      	MOVLW 0x20
09E0  102B      	IORWF CompTempVar2188, W
09E2  6E83      	MOVWF gbl_portd

		else
			portd = portd & 0xdf;


	} else {
09E4  D006      	BRA	label18
09F2            label18

		//Sortie
		//Sortie: 0 -> D5
		trisd = trisd & 0xdf;
09E6  0EDF      	MOVLW 0xDF
09E8  1495      	ANDWF gbl_trisd, W
09EA  6E95      	MOVWF gbl_trisd

		if (0)
			portd = (portd & 0xdf) | 0x20;
		else
			portd = portd & 0xdf;
09EC  0EDF      	MOVLW 0xDF
09EE  1483      	ANDWF gbl_portd, W
09F0  6E83      	MOVWF gbl_portd



	}


	//Décision
	//Décision: showBattLevel.batLevel > 217?
	if (FCL_BATLEVEL > 217)
09F2  0ED9      	MOVLW 0xD9
09F4  642A      	CPFSGT FCM_showBa_0003E_1_FCL_BATLEVEL
09F6  D00A      	BRA	label19
0A0C            label19

	{
		//Sortie
		//Sortie: 1 -> D6
		trisd = trisd & 0xbf;
09F8  0EBF      	MOVLW 0xBF
09FA  1495      	ANDWF gbl_trisd, W
09FC  6E95      	MOVWF gbl_trisd

		if (1)
			portd = (portd & 0xbf) | 0x40;
09FE  0EBF      	MOVLW 0xBF
0A00  1483      	ANDWF gbl_portd, W
0A02  6E2B      	MOVWF CompTempVar2189
0A04  0E40      	MOVLW 0x40
0A06  102B      	IORWF CompTempVar2189, W
0A08  6E83      	MOVWF gbl_portd

		else
			portd = portd & 0xbf;


	} else {
0A0A  D006      	BRA	label20
0A18            label20

		//Sortie
		//Sortie: 0 -> D6
		trisd = trisd & 0xbf;
0A0C  0EBF      	MOVLW 0xBF
0A0E  1495      	ANDWF gbl_trisd, W
0A10  6E95      	MOVWF gbl_trisd

		if (0)
			portd = (portd & 0xbf) | 0x40;
		else
			portd = portd & 0xbf;
0A12  0EBF      	MOVLW 0xBF
0A14  1483      	ANDWF gbl_portd, W
0A16  6E83      	MOVWF gbl_portd



	}


	//Décision
	//Décision: showBattLevel.batLevel > 254?
	if (FCL_BATLEVEL > 254)
0A18  0EFE      	MOVLW 0xFE
0A1A  642A      	CPFSGT FCM_showBa_0003E_1_FCL_BATLEVEL
0A1C  D00A      	BRA	label21
0A32            label21

	{
		//Sortie
		//Sortie: 1 -> D7
		trisd = trisd & 0x7f;
0A1E  0E7F      	MOVLW 0x7F
0A20  1495      	ANDWF gbl_trisd, W
0A22  6E95      	MOVWF gbl_trisd

		if (1)
			portd = (portd & 0x7f) | 0x80;
0A24  0E7F      	MOVLW 0x7F
0A26  1483      	ANDWF gbl_portd, W
0A28  6E2B      	MOVWF CompTempVar2190
0A2A  0E80      	MOVLW 0x80
0A2C  102B      	IORWF CompTempVar2190, W
0A2E  6E83      	MOVWF gbl_portd

		else
			portd = portd & 0x7f;


	} else {
		//Sortie
		//Sortie: 0 -> D7
		trisd = trisd & 0x7f;
0A32  0E7F      	MOVLW 0x7F
0A34  1495      	ANDWF gbl_trisd, W
0A36  6E95      	MOVWF gbl_trisd

		if (0)
			portd = (portd & 0x7f) | 0x80;
		else
			portd = portd & 0x7f;
0A38  0E7F      	MOVLW 0x7F
0A3A  1483      	ANDWF gbl_portd, W
0A3C  6E83      	MOVWF gbl_portd



	}


}
0A30  0012      	RETURN
0A3E  0012      	RETURN


char FCM_isBattLevelOK(char FCL_PRCT)

{
	
	//Définitions des variables locales
	char FCL_BATTLEVEL;

	char FCR_RETVAL;

	//Appel d'une Macro
	//Appel d'une Macro: isBattLevelOK.battLevel=getBat
	FCL_BATTLEVEL = FCM_getBat();
0A40  EC7CF004  	CALL FCM_getBat_00000
0A44  502E      	MOVF CompTempVarRet2191, W
0A46  6E2B      	MOVWF FCM_isBatt_0003F_1_FCL_BATTLEVEL



	//Décision
	//Décision: isBattLevelOK.battLevel >= isBattLevelOK.prct?
	if (FCL_BATTLEVEL >= FCL_PRCT)
0A48  502B      	MOVF FCM_isBatt_0003F_1_FCL_BATTLEVEL, W
0A4A  642A      	CPFSGT FCM_isBatt_0003F_arg_FCL_PRCT
0A4C  D001      	BRA	label22
0A4E  D003      	BRA	label23
0A50            label22
0A56            label23

	{
		//Calcul
		//Calcul:
		//  isBattLevelOK.Return = true
		FCR_RETVAL = FCV_TRUE;
0A50  5027      	MOVF gbl_FCV_TRUE, W
0A52  6E2C      	MOVWF FCM_isBatt_0003F_1_FCR_RETVAL

		

	} else {
0A54  D002      	BRA	label24
0A5A            label24

		//Calcul
		//Calcul:
		//  isBattLevelOK.Return = false
		FCR_RETVAL = FCV_FALSE;
0A56  5026      	MOVF gbl_FCV_FALSE, W
0A58  6E2C      	MOVWF FCM_isBatt_0003F_1_FCR_RETVAL

		

	}


	return (FCR_RETVAL);
0A5A  502C      	MOVF FCM_isBatt_0003F_1_FCR_RETVAL, W
0A5C  6E2D      	MOVWF CompTempVarRet2192

}
0A5E  0012      	RETURN


char FCM_getBat()

{
	
	char FCR_RETVAL;

	//Appel de la Routine Composant
	//Appel de la Routine Composant: getBat.Return=ADC(0)::Lire_comme_Octet
	FCR_RETVAL = FCD_ADC0_ReadAsByte();
08F8  EC77F004  	CALL FCD_ADC0_R_00040
08FC  502E      	MOVF CompTempVarRet2193, W
08FE  6E2D      	MOVWF FCM_getBat_00000_1_FCR_RETVAL



	return (FCR_RETVAL);
0900  502D      	MOVF FCM_getBat_00000_1_FCR_RETVAL, W
0902  6E2E      	MOVWF CompTempVarRet2191

}
0904  0012      	RETURN


char FCM_getTrou(short FCL_TIMEOUT)

{
	
	//Définitions des variables locales
	short FCL_T;
	char FCL_CAPT;

	char FCR_RETVAL;

	//Calcul
	//Calcul:
	//  getTrou.Return = false
	//  getTrou.t = 0
	FCR_RETVAL = FCV_FALSE;
0AB0  5026      	MOVF gbl_FCV_FALSE, W
0AB2  6E2F      	MOVWF FCM_getTro_00041_1_FCR_RETVAL

	FCL_T = 0;
0AB4  6A2C      	CLRF FCM_getTro_00041_1_FCL_T
0AB6  6A2D      	CLRF FCM_getTro_00041_1_FCL_T+D'1'

	

	//Boucle
	//Boucle: Tant que getTrou.t < getTrou.timeout && getTrou.Return == false
	while (1)
0AB8            label28

	{
		//Entrée
		//Entrée: C0 -> getTrou.capt
		trisc = trisc | 0x01;
0AB8  0E01      	MOVLW 0x01
0ABA  1094      	IORWF gbl_trisc, W
0ABC  6E94      	MOVWF gbl_trisc

		FCL_CAPT = ((portc & 0x01) == 0x01);
0ABE  0E01      	MOVLW 0x01
0AC0  1482      	ANDWF gbl_portc, W
0AC2  6E33      	MOVWF CompTempVar2198
0AC4  6A2E      	CLRF FCM_getTro_00041_1_FCL_CAPT
0AC6  0433      	DECF CompTempVar2198, W
0AC8  B4D8      	BTFSC STATUS,Z
0ACA  2A2E      	INCF FCM_getTro_00041_1_FCL_CAPT, F



		//Décision
		//Décision: getTrou.capt?
		if (FCL_CAPT)
0ACC  522E      	MOVF FCM_getTro_00041_1_FCL_CAPT, F
0ACE  E002      	BZ	label29
0AD4            label29

		{
			//Calcul
			//Calcul:
			//  getTrou.Return = true
			FCR_RETVAL = FCV_TRUE;
0AD0  5027      	MOVF gbl_FCV_TRUE, W
0AD2  6E2F      	MOVWF FCM_getTro_00041_1_FCR_RETVAL

			

		}


		//Calcul
		//Calcul:
		//  getTrou.t = getTrou.t + 25
		FCL_T = FCL_T + 25;
0AD4  6A33      	CLRF CompTempVar2201
0AD6  0E19      	MOVLW 0x19
0AD8  262C      	ADDWF FCM_getTro_00041_1_FCL_T, F
0ADA  502D      	MOVF FCM_getTro_00041_1_FCL_T+D'1', W
0ADC  2233      	ADDWFC CompTempVar2201, F
0ADE  5033      	MOVF CompTempVar2201, W
0AE0  6E2D      	MOVWF FCM_getTro_00041_1_FCL_T+D'1'

		

		//Pause
		//Pause: 25 ms
		delay_ms(25);
0AE2  0E19      	MOVLW 0x19
0AE4  6E33      	MOVWF delay_ms_00000_arg_del
0AE6  EC06F004  	CALL delay_ms_00000



		if ((FCL_T < FCL_TIMEOUT && FCR_RETVAL == FCV_FALSE) == 0) break;
0AEA  6A31      	CLRF CompTempVar2196
0AEC  502D      	MOVF FCM_getTro_00041_1_FCL_T+D'1', W
0AEE  0A80      	XORLW 0x80
0AF0  6E33      	MOVWF CompTempVar2202
0AF2  502B      	MOVF FCM_getTro_00041_arg_FCL_TIMEOUT+D'1', W
0AF4  0A80      	XORLW 0x80
0AF6  5C33      	SUBWF CompTempVar2202, W
0AF8  6231      	CPFSEQ CompTempVar2196
0AFA  D004      	BRA	label30
0AFC  502A      	MOVF FCM_getTro_00041_arg_FCL_TIMEOUT, W
0AFE  602C      	CPFSLT FCM_getTro_00041_1_FCL_T
0B00  D001      	BRA	label30
0B02  D001      	BRA	label31
0B04            label30
0B04  A0D8      	BTFSS STATUS,C
0B06  7031      	BTG CompTempVar2196,0
0B08  6A30      	CLRF CompTempVar2195
0B0A  5026      	MOVF gbl_FCV_FALSE, W
0B0C  622F      	CPFSEQ FCM_getTro_00041_1_FCR_RETVAL
0B0E  D001      	BRA	label32
0B10  2A30      	INCF CompTempVar2195, F
0B12            label32
0B12  6A32      	CLRF CompTempVar2197
0B14  5230      	MOVF CompTempVar2195, F
0B16  A4D8      	BTFSS STATUS,Z
0B18  5231      	MOVF CompTempVar2196, F
0B1A  A4D8      	BTFSS STATUS,Z
0B1C  2A32      	INCF CompTempVar2197, F
0B1E  5232      	MOVF CompTempVar2197, F
0B20  E1CB      	BNZ	label28

	}


	return (FCR_RETVAL);
0B22  502F      	MOVF FCM_getTro_00041_1_FCR_RETVAL, W
0B24  6E30      	MOVWF CompTempVarRet2194

}
0B26  0012      	RETURN


void main()

{
	
	//Initialisation
	adcon1 = 0x0F;
0B6A  0E0F      	MOVLW 0x0F
0B6C  6EC1      	MOVWF gbl_adcon1

	ucfg = 0x08;
0B6E  0E08      	MOVLW 0x08
0B70  6E6F      	MOVWF gbl_ucfg

cr_bit(pie2, USBIE);
0B72  9AA0      	BCF gbl_pie2,5



	//Code d'initialisation d'Interruption
	


	//Calcul
	//Calcul:
	//  true = 1
	//  false = 0
	FCV_TRUE = 1;
0B74  0E01      	MOVLW 0x01
0B76  6E27      	MOVWF gbl_FCV_TRUE

	FCV_FALSE = 0;
0B78  6A26      	CLRF gbl_FCV_FALSE

	

	//Appel d'une Macro
	//Appel d'une Macro: initLed
	FCM_initLed();
0B7A  EC30F005  	CALL FCM_initLe_0003D



	//Boucle
	//Boucle: Tant que 1
	while (1)
0B7E            label35
0C0A  D7B9      	BRA	label35

	{
		//Appel d'une Macro
		//Appel d'une Macro: showBattLevel
		FCM_showBattLevel();
0B7E  EC83F004  	CALL FCM_showBa_0003E



		//Appel d'une Macro
		//Appel d'une Macro: battLevelOk=isBattLevelOK(128)
		FCV_BATTLEVELOK = FCM_isBattLevelOK(128);
0B82  0E80      	MOVLW 0x80
0B84  6E2A      	MOVWF FCM_isBatt_0003F_arg_FCL_PRCT
0B86  EC20F005  	CALL FCM_isBatt_0003F
0B8A  502D      	MOVF CompTempVarRet2192, W
0B8C  6E25      	MOVWF gbl_FCV_BATTLEVELOK



		//Décision
		//Décision: battLevelOk?
		if (FCV_BATTLEVELOK)
0B8E  5225      	MOVF gbl_FCV_BATTLEVELOK, F
0B90  E034      	BZ	label36
0BFA            label36

		{
			//Commentaire:
			//C'est parti !!!


			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::Enable(1)
			FCD_PWM0_Enable(1);
0B92  0E01      	MOVLW 0x01
0B94  6E2A      	MOVWF FCD_PWM0_E_00047_arg_nIdx
0B96  EC9EF005  	CALL FCD_PWM0_E_00047



			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::Enable(2)
			FCD_PWM0_Enable(2);
0B9A  0E02      	MOVLW 0x02
0B9C  6E2A      	MOVWF FCD_PWM0_E_00047_arg_nIdx
0B9E  EC9EF005  	CALL FCD_PWM0_E_00047



			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::SetDutyCycle(1, 128)
			FCD_PWM0_SetDutyCycle(1, 128);
0BA2  0E01      	MOVLW 0x01
0BA4  6E2A      	MOVWF FCD_PWM0_S_00049_arg_nIdx
0BA6  0E80      	MOVLW 0x80
0BA8  6E2B      	MOVWF FCD_PWM0_S_00049_arg_nDuty
0BAA  EC94F005  	CALL FCD_PWM0_S_00049



			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::SetDutyCycle(2, 128)
			FCD_PWM0_SetDutyCycle(2, 128);
0BAE  0E02      	MOVLW 0x02
0BB0  6E2A      	MOVWF FCD_PWM0_S_00049_arg_nIdx
0BB2  0E80      	MOVLW 0x80
0BB4  6E2B      	MOVWF FCD_PWM0_S_00049_arg_nDuty
0BB6  EC94F005  	CALL FCD_PWM0_S_00049



			//Appel d'une Macro
			//Appel d'une Macro: isTrou=getTrou(1000)
			FCV_ISTROU = FCM_getTrou(1000);
0BBA  0EE8      	MOVLW 0xE8
0BBC  6E2A      	MOVWF FCM_getTro_00041_arg_FCL_TIMEOUT
0BBE  0E03      	MOVLW 0x03
0BC0  6E2B      	MOVWF FCM_getTro_00041_arg_FCL_TIMEOUT+D'1'
0BC2  EC58F005  	CALL FCM_getTro_00041
0BC6  5030      	MOVF CompTempVarRet2194, W
0BC8  6E24      	MOVWF gbl_FCV_ISTROU



			//Décision
			//Décision: isTrou?
			if (FCV_ISTROU)
0BCA  5224      	MOVF gbl_FCV_ISTROU, F
0BCC  E0D8      	BZ	label35

			{
				//Appel de la Routine Composant
				//Appel de la Routine Composant: PWM(0)::Disable(1)
				FCD_PWM0_Disable(1);
0BCE  0E01      	MOVLW 0x01
0BD0  6E2A      	MOVWF FCD_PWM0_D_00048_arg_nIdx
0BD2  ECADF005  	CALL FCD_PWM0_D_00048



				//Appel de la Routine Composant
				//Appel de la Routine Composant: PWM(0)::Disable(2)
				FCD_PWM0_Disable(2);
0BD6  0E02      	MOVLW 0x02
0BD8  6E2A      	MOVWF FCD_PWM0_D_00048_arg_nIdx
0BDA  ECADF005  	CALL FCD_PWM0_D_00048



				//Pause
				//Pause: 1000 s
				delay_s(255);
0BDE  682A      	SETF delay_s_00000_arg_del
0BE0  EC48F004  	CALL delay_s_00000

				delay_s(255);
0BE4  682A      	SETF delay_s_00000_arg_del
0BE6  EC48F004  	CALL delay_s_00000

				delay_s(255);
0BEA  682A      	SETF delay_s_00000_arg_del
0BEC  EC48F004  	CALL delay_s_00000

				delay_s(235);
0BF0  0EEB      	MOVLW 0xEB
0BF2  6E2A      	MOVWF delay_s_00000_arg_del
0BF4  EC48F004  	CALL delay_s_00000



				//Commentaire:
				//Dépliage pont !!!!!


			}


		} else {
0BF8  D7C2      	BRA	label35

			//Commentaire:
			//Nope :(


			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::Disable(1)
			FCD_PWM0_Disable(1);
0BFA  0E01      	MOVLW 0x01
0BFC  6E2A      	MOVWF FCD_PWM0_D_00048_arg_nIdx
0BFE  ECADF005  	CALL FCD_PWM0_D_00048



			//Appel de la Routine Composant
			//Appel de la Routine Composant: PWM(0)::Disable(2)
			FCD_PWM0_Disable(2);
0C02  0E02      	MOVLW 0x02
0C04  6E2A      	MOVWF FCD_PWM0_D_00048_arg_nIdx
0C06  ECADF005  	CALL FCD_PWM0_D_00048



		}


	}


	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
0C56  CFEAF001  	MOVFF FSR0H,  Int1Context
0C5A  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
0C5E  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
0C62  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
0C66  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
0C6A  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
0C6E  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
0C72  C001FFEA  	MOVFF Int1Context,  FSR0H
0C76  0011      	RETFIE 1





////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0800  EF06F006  	GOTO	_startup

0808  EF2BF006  	GOTO	interrupt
080C            delay_ms_00000
080C            ; { delay_ms ; function begin
080C  5233      	MOVF delay_ms_00000_arg_del, F
080E  0000      	NOP
0810  E101      	BNZ	label1
0812  0012      	RETURN
0814            label1
0814  0EFF      	MOVLW 0xFF
0816            label2
0816  0000      	NOP
0818  0000      	NOP
081A  0000      	NOP
081C  0000      	NOP
081E  0000      	NOP
0820  0000      	NOP
0822  0000      	NOP
0824  0000      	NOP
0826  0000      	NOP
0828  0000      	NOP
082A  0000      	NOP
082C  0000      	NOP
082E  0000      	NOP
0830  0000      	NOP
0832  0000      	NOP
0834  0000      	NOP
0836  0000      	NOP
0838  0000      	NOP
083A  0000      	NOP
083C  0000      	NOP
083E  0000      	NOP
0840  0000      	NOP
0842  0000      	NOP
0844  0000      	NOP
0846  0000      	NOP
0848  0000      	NOP
084A  0000      	NOP
084C  0000      	NOP
084E  0000      	NOP
0850  0000      	NOP
0852  0000      	NOP
0854  0000      	NOP
0856  0000      	NOP
0858  0000      	NOP
085A  0000      	NOP
085C  0000      	NOP
085E  0000      	NOP
0860  0000      	NOP
0862  0000      	NOP
0864  0000      	NOP
0866  0000      	NOP
0868  0000      	NOP
086A  0000      	NOP
086C  0FFF      	ADDLW 0xFF
086E  A4D8      	BTFSS STATUS,Z
0870  D7D2      	BRA	label2
0872  0000      	NOP
0874  0000      	NOP
0876  0000      	NOP
0878  0000      	NOP
087A  0000      	NOP
087C  0000      	NOP
087E  0000      	NOP
0880  0000      	NOP
0882  0000      	NOP
0884  0000      	NOP
0886  0000      	NOP
0888  0000      	NOP
088A  2E33      	DECFSZ delay_ms_00000_arg_del, F
088C  D7C3      	BRA	label1
088E  0012      	RETURN
0890            ; } delay_ms function end

0890            delay_s_00000
0890            ; { delay_s ; function begin
0890            label3
0890  0EFA      	MOVLW 0xFA
0892  6E33      	MOVWF delay_ms_00000_arg_del
0894  EC06F004  	CALL delay_ms_00000
0898  0EFA      	MOVLW 0xFA
089A  6E33      	MOVWF delay_ms_00000_arg_del
089C  EC06F004  	CALL delay_ms_00000
08A0  0EFA      	MOVLW 0xFA
08A2  6E33      	MOVWF delay_ms_00000_arg_del
08A4  EC06F004  	CALL delay_ms_00000
08A8  0EFA      	MOVLW 0xFA
08AA  6E33      	MOVWF delay_ms_00000_arg_del
08AC  EC06F004  	CALL delay_ms_00000
08B0  2E2A      	DECFSZ delay_s_00000_arg_del, F
08B2  D7EE      	BRA	label3
08B4  0012      	RETURN
08B6            ; } delay_s function end


0C0C            _startup
0C0C  0ED5      	MOVLW 0xD5
0C0E  6E05      	MOVWF gbl_16_LSR
0C10  0EC4      	MOVLW 0xC4
0C12  6E06      	MOVWF gbl_16_LSR+D'1'
0C14  0EBB      	MOVLW 0xBB
0C16  6E07      	MOVWF gbl_16_LSR+D'2'
0C18  0EDC      	MOVLW 0xDC
0C1A  6E08      	MOVWF gbl_16_LSR+D'3'
0C1C  6A09      	CLRF gbl_17_gbl_aSig
0C1E  6A0A      	CLRF gbl_17_gbl_aSig+D'1'
0C20  6A0B      	CLRF gbl_17_gbl_aSig+D'2'
0C22  6A0C      	CLRF gbl_17_gbl_aSig+D'3'
0C24  6A0D      	CLRF gbl_17_gbl_bSig
0C26  6A0E      	CLRF gbl_17_gbl_bSig+D'1'
0C28  6A0F      	CLRF gbl_17_gbl_bSig+D'2'
0C2A  6A10      	CLRF gbl_17_gbl_bSig+D'3'
0C2C  6A11      	CLRF gbl_17_gbl_zSig
0C2E  6A12      	CLRF gbl_17_gbl_zSig+D'1'
0C30  6A13      	CLRF gbl_17_gbl_zSig+D'2'
0C32  6A14      	CLRF gbl_17_gbl_zSig+D'3'
0C34  6A1E      	CLRF gbl_17_gbl_aExp
0C36  6A1F      	CLRF gbl_17_gbl_bExp
0C38  6A19      	CLRF gbl_17_gbl_zExp
0C3A  6A1A      	CLRF gbl_17_gbl_zExp+D'1'
0C3C  6A20      	CLRF gbl_17_gbl_aSign
0C3E  6A21      	CLRF gbl_17_gbl_bSign
0C40  6A22      	CLRF gbl_17_gbl_zSign
0C42  6A23      	CLRF gbl_17_gbl_zSigZero
0C44  6A15      	CLRF gbl_17_gbl_ret
0C46  6A16      	CLRF gbl_17_gbl_ret+D'1'
0C48  6A17      	CLRF gbl_17_gbl_ret+D'2'
0C4A  6A18      	CLRF gbl_17_gbl_ret+D'3'
0C4C  6A1C      	CLRF gbl_float_rounding_mode
0C4E  6A1D      	CLRF gbl_float_exception_flags
0C50  6A1B      	CLRF gbl_float_detect_tininess
0C52  EFB5F005  	GOTO	main

300000  0E20      	DW 0x0E20
300002  1E3E      	DW 0x1E3E
300004  8100      	DW 0x8100
300006  0081      	DW 0x0081
300008  800F      	DW 0x800F
30000A  A00F      	DW 0xA00F
30000C  000F      	DW 0x000F
