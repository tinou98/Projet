;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.03
;// License Type  : Full License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited, Non commercial use only
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  File name:     P:\SI\Projet\FlowCode\BattLevel.c
//**  Generated by:  Flowcode v4.5.18.74
//**  Date:          Friday, April 10, 2015 09:16:22
//**  Licence:       10 User
//**  Registered to: LYCEE-STMARC38-02
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL 
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Définir pour microcontrôleur
#define P18F4455
#define MX_EE
#define MX_EE_TYPE3
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_BCB
#define MX_SPI_SDI 0
#define MX_SPI_SDO 7
#define MX_SPI_SCK 1
#define MX_UART
#define MX_UART_C
#define MX_UART_TX 6
#define MX_UART_RX 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_B
#define MX_I2C_SDA 0
#define MX_I2C_SCL 1
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 2
#define MX_PWM_TRIS2 trisc
#define MX_PWM_2 1
#define MX_PWM_TRIS2a trisb
#define MX_PWM_2a 3
#define MX_USB_TYPE1

//Fonctions
#define MX_CLK_SPEED 48000000
#ifdef _BOOSTC
#include <system.h>
#endif
#ifdef HI_TECH_C
#include <pic18.h>
#endif

//Données de Configuration
#ifdef _BOOSTC
#pragma DATA 0x300000, 0x20
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0xe
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0x3e
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0x1e
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x81
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0x81
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0x80
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xa0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xf
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0x0
#endif
#ifdef _HI_TECH_C
%C__CONFIG(%A, %V);
#endif

//Fonctions internes
#include "C:\Program Files\Matrix Multimedia\Flowcode V4\FCD\internals.h"

//Déclarations de fonction Macro
void FCM_initLed();
void FCM_showLevel(char FCL_LEVEL);
char FCM_isBattLevelOK(char FCL_PRCT);
char FCM_getBat();
char FCM_getTrou(short FCL_TIMEOUT);
void FCM_move(short FCL_VITESSE, short FCL_SENS, short FCL_DEGRE);
void FCM_align();
void FCM_verrin(char FCL_MONTE);
char FCM_getTrouState(char FCL_NB);


//Déclarations de Variable
char FCV_STOP;
char FCV_PB;
char FCV_I;
char FCV__1;
char FCV__2;
char FCV_LEFT;
char FCV_RIGHT;
char FCV__3;
char FCV_DROIT;
char FCV_ARRIERE;
char FCV_ISTROU;
char FCV_BATTLEVELOK;
char FCV_AVANT;
char FCV_TRUE;
char FCV_FALSE;

char FCLV_LOOP1;
char FCLV_LOOP2;



//PWM(0): //Defines:

/**** Macro Substitutions ****
255 = Timer 2 Rollover Value
0x04 = Timer 2 Prescaler Value
-1 = MIAC System ID
0 = Alternate Pin FCD_PWM0_Enable
******************************/




//PWM(0): //Déclarations de fonction Macro

void FCD_PWM0_Enable(char nIdx);
void FCD_PWM0_Disable(char nIdx);
void FCD_PWM0_SetDutyCycle(char nIdx, char nDuty);
void FCD_PWM0_ChangePeriod(char nPeriodVal, char nPrescalerVal);
void FCD_PWM0_SetDutyCycle10bit(char nIdx, short nDuty);


//ADC(0): //Defines:

/**** Macro Substitutions ****
12 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
0 = VRef+ Option
500 = VRef Voltage x 0.01V
0 = MIAC System ordinal
0 = MIAC System module type
******************************/




//ADC(0): //Déclarations de fonction Macro

void FCD_ADC0_SampleADC();
char FCD_ADC0_ReadAsByte();
short FCD_ADC0_ReadAsInt();
float FCD_ADC0_ReadAsVoltage();
void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);


//ADC(2): //Defines:

/**** Macro Substitutions ****
9 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
0 = VRef+ Option
500 = VRef Voltage x 0.01V
0 = MIAC System ordinal
0 = MIAC System module type
******************************/




//ADC(2): //Déclarations de fonction Macro

void FCD_ADC2_SampleADC();
char FCD_ADC2_ReadAsByte();
short FCD_ADC2_ReadAsInt();
float FCD_ADC2_ReadAsVoltage();
void FCD_ADC2_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);


//ADC(3): //Defines:

/**** Macro Substitutions ****
9 = Which ADC Channel
40 = Acquisition time
3 = Conversion Speed
0 = VRef+ Option
500 = VRef Voltage x 0.01V
0 = MIAC System ordinal
0 = MIAC System module type
******************************/




//ADC(3): //Déclarations de fonction Macro

void FCD_ADC3_SampleADC();
char FCD_ADC3_ReadAsByte();
short FCD_ADC3_ReadAsInt();
float FCD_ADC3_ReadAsVoltage();
void FCD_ADC3_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE);


//Stepper(0): //Defines:

/**** Macro Substitutions ****
portd = Coil 1 Port Register
trisd = Coil 1 Data Direction Register
0 = Coil 1 Pin
portd = Coil 2 Port Register
trisd = Coil 2 Data Direction Register
1 = Coil 2 Pin
portd = Coil 3 Port Register
trisd = Coil 3 Data Direction Register
2 = Coil 3 Pin
portd = Coil 4 Port Register
trisd = Coil 4 Data Direction Register
7 = Coil 4 Pin
0 = Step Type - 0 = half step, 1 = full step (2-2), 2 = wave (1-1)
0 = Motor Type - 0 = bipolar/unipolar +ve, 1 = unipolar -ve
0 = Number of Full Steps Per Revolution
0 = Unused
Stepper_263108 = Unique Component Identifier
******************************/

//common defines
#define MX_Stepper_263108_PORT1			portd	//0
#define MX_Stepper_263108_TRIS1			trisd
#define MX_Stepper_263108_PIN1			0
#define MX_Stepper_263108_PORT2			portd	//1
#define MX_Stepper_263108_TRIS2			trisd
#define MX_Stepper_263108_PIN2			1
#define MX_Stepper_263108_PORT3			portd	//2
#define MX_Stepper_263108_TRIS3			trisd
#define MX_Stepper_263108_PIN3			2
#define MX_Stepper_263108_PORT4			portd	//3
#define MX_Stepper_263108_TRIS4			trisd
#define MX_Stepper_263108_PIN4			7
#define MX_Stepper_263108_STEP_TYPE		0	//0 = half step, 1 = full step (2-2), 2 = wave (1-1)
#define MX_Stepper_263108_WINDING_TYPE	0	//0 = bipolar/unipolar +ve, 1 = unipolar -ve


#if (MX_Stepper_263108_WINDING_TYPE == 2)
	char Stepper_263108_pattern[8] = {0x06, 0x0e, 0x0a, 0x0b, 0x09, 0x0d, 0x05, 0x07};
#else
	char Stepper_263108_pattern[8] = {0x09, 0x01, 0x05, 0x04, 0x06, 0x02, 0x0a, 0x08};
0A7E  0E09      	MOVLW 0x09
0A80  6E05      	MOVWF gbl_Stepper_263108_pattern
0A82  0E01      	MOVLW 0x01
0A84  6E06      	MOVWF gbl_Stepper_263108_pattern+D'1'
0A86  0E05      	MOVLW 0x05
0A88  6E07      	MOVWF gbl_Stepper_263108_pattern+D'2'
0A8A  0E04      	MOVLW 0x04
0A8C  6E08      	MOVWF gbl_Stepper_263108_pattern+D'3'
0A8E  0E06      	MOVLW 0x06
0A90  6E09      	MOVWF gbl_Stepper_263108_pattern+D'4'
0A92  0E02      	MOVLW 0x02
0A94  6E0A      	MOVWF gbl_Stepper_263108_pattern+D'5'
0A96  0E0A      	MOVLW 0x0A
0A98  6E0B      	MOVWF gbl_Stepper_263108_pattern+D'6'
0A9A  0E08      	MOVLW 0x08
0A9C  6E0C      	MOVWF gbl_Stepper_263108_pattern+D'7'

#endif


#if (MX_Stepper_263108_STEP_TYPE == 0)
	#define MX_Stepper_263108_INC_STEP	1
#else
	#define MX_Stepper_263108_INC_STEP	2
#endif

char Stepper_263108_phase = 0;
0A9E  6A34      	CLRF gbl_Stepper_263108_phase

char Stepper_263108_enabled = 0;
0AA0  6A35      	CLRF gbl_Stepper_263108_enabled





//Stepper(0): //Déclarations de fonction Macro

void FCD_Stepper0_IncrementStep();
void FCD_Stepper0_DecrementStep();
void FCD_Stepper0_EnableMotor();
void FCD_Stepper0_DisableMotor();

//Définitions supplémentaires
#define MOTEUR_AVANCE 1



//PWM(0): //Implémentations Macro


void FCD_PWM0_Enable(char nIdx)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif

	#ifdef MX_MIAC_EXTERNAL
		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[1] = 255;
		MIAC_CAN_TX[2] = 0x04;
		MIAC_Module_WR(ModID, 320, 3, 1, 0);
		MIAC_Module_GetAck(ModID + 32, 320, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  #ifndef MX_PWM		//error checking
		#error "This chip does not have PWM capability"
	  #else
		#ifndef MX_PWM_CNT
			#error "FCD file error (no MX_PWM_CNT)"
		#endif
		#if (MX_PWM_CNT < 1)
			#error "FCD file error (MX_PWM_CNT < 1)"
		#endif
		//#if (MX_PWM_CNT > 2)
		//	#error "FCD file error (MX_PWM_CNT > 2)"
		//#endif
		#ifndef MX_PWM_TRIS1
			#error "FCD file error (no MX_PWM_TRIS1)"
		#endif
		#ifndef MX_PWM_1
			#error "FCD file error (no MX_PWM_1)"
		#endif
	    #if (MX_PWM_CNT == 2)
	      	#ifndef MX_PWM_TRIS2
				#error "FCD file error (no MX_PWM_TRIS2)"
	      	#endif
	      	#ifndef MX_PWM_2
				#error "FCD file error (no MX_PWM_2)"
	      	#endif
	    #endif
	    #if (0 == 1)
	      	#ifndef MX_PWM_TRIS1a
				#error "PWM component error (using alternative, but no MX_PWM_TRIS1a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	      	#ifndef MX_PWM_1a
				#error "PWM component error (using alternative, but no MX_PWM_1a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	    #endif
	    #if (0 == 2)
	      	#ifndef MX_PWM_TRIS2a
				#error "PWM component error (using alternative, but no MX_PWM_TRIS2a)"
	  			#define MX_PWM_ALT_ERROR
	      	#endif
	      	#ifndef MX_PWM_2a
				#error "PWM component error (using alternative, but no MX_PWM_2a)"
	        	#define MX_PWM_ALT_ERROR
	      	#endif
	    #endif

	 	#ifdef MX_PWM
			pr2 = 255;
			t2con = 0x04;
		#endif

	  	#if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccp1con = 0x0C;

			  	#if (0 == 1)
			   		#ifndef MX_PWM_ALT_ERROR
						clear_bit(MX_PWM_TRIS1a, MX_PWM_1a);
			   		#endif
			  	#else
					clear_bit(MX_PWM_TRIS1, MX_PWM_1);
			  	#endif
			}
	  	#endif

	  	#if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccp2con = 0x0C;
			  	#if (0 == 2)
			   		#ifndef MX_PWM_ALT_ERROR
						clear_bit(MX_PWM_TRIS2a, MX_PWM_2a);
			   		#endif
			 	#else
					clear_bit(MX_PWM_TRIS2, MX_PWM_2);
			  	#endif
		   }
	  	#endif
	  #endif

	  #ifdef MX_PWM_ALT_ERROR
	   #undef MX_PWM_ALT_ERROR
	  #endif

	#endif

}

void FCD_PWM0_Disable(char nIdx)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL
		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_Module_WR(ModID, 321, 1, 1, 0);
		MIAC_Module_GetAck(ModID, 321, 20);

		#undef MX_MIAC_EXTERNAL

	#else

	 	#ifndef MX_PWM		//error checking
			#error "This chip does not have PWM capability"
	  	#else
		  	#if (MX_PWM_CNT >= 1)
				if (nIdx == 1)
				{
					ccp1con = 0x00;
				}
		  	#endif

		  	#if (MX_PWM_CNT >= 2)
				if (nIdx == 2)
				{
					ccp2con = 0x00;
				}
		  	#endif
	 	#endif
	#endif

}

void FCD_PWM0_SetDutyCycle(char nIdx, char nDuty)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif

	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[1] = nDuty;
		MIAC_Module_WR(ModID, 322, 2, 1, 0);
		MIAC_Module_GetAck(ModID, 322, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  //error checking
	  #ifndef MX_PWM
		#error "This chip does not have PWM capability"
	  #else
		  #if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccpr1l = nDuty;
			}
		  #endif

		  #if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccpr2l = nDuty;
			}
		  #endif
	 #endif
	#endif

}

void FCD_PWM0_ChangePeriod(char nPeriodVal, char nPrescalerVal)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nPeriodVal;
		MIAC_CAN_TX[1] = nPrescalerVal;
		MIAC_CAN_TX[2] = (nPrescalerVal >> 8);
		MIAC_Module_WR(ModID, 323, 3, 1, 0);
		MIAC_Module_GetAck(ModID, 323, 20);

		#undef MX_MIAC_EXTERNAL
	#else

	  //error checking
	  #ifndef MX_PWM
			#error "This chip does not have PWM capability"
	  #else
	    pr2 = nPeriodVal;

	    switch (nPrescalerVal)
	    {
	        case 1:
	            t2con = 0x04;
	            break;

	        case 4:
	            t2con = 0x05;
	            break;

	        case 16:
	            t2con = 0x06;
	            break;
	    }
	  #endif
	#endif

}

void FCD_PWM0_SetDutyCycle10bit(char nIdx, short nDuty)
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if ((-1 & 0x001f) != MX_MIAC_MM_MIAC_BASE)
		#define MX_MIAC_EXTERNAL
	  #endif
	#endif


	#ifdef MX_MIAC_EXTERNAL

		short ModID = (((-1 & 0x0300) << 1) + ((-1 & 0x001f) << 4)) << 5;

		MIAC_CAN_TX[0] = nIdx;
		MIAC_CAN_TX[2] = nDuty;
		MIAC_CAN_TX[1] = (nDuty >> 8);
		MIAC_Module_WR(ModID, 324, 3, 1, 0);
		MIAC_Module_GetAck(ModID, 324, 20);

		#undef MX_MIAC_EXTERNAL
	#else

		char nCCPxCONtemp;

	  //error checking
	  #ifndef MX_PWM
	  	#error "This chip does not have PWM capability"
	  #else
		  #if (MX_PWM_CNT >= 1)
			if (nIdx == 1)
			{
				ccpr1l = (nDuty & 0x3FC) >> 2;

				nDuty = (nDuty & 0x03) << 4;
				nCCPxCONtemp = (ccp1con & 0xCF) | nDuty;
				ccp1con = nCCPxCONtemp;
			}
		  #endif

		  #if (MX_PWM_CNT >= 2)
			if (nIdx == 2)
			{
				ccpr2l = (nDuty & 0x3FC) >> 2;

				nDuty = (nDuty & 0x03) << 4;
				nCCPxCONtemp = (ccp2con & 0xCF) | nDuty;
				ccp2con = nCCPxCONtemp;
			}
		  #endif
	 #endif
	#endif

}



//ADC(0): //Implémentations Macro


void FCD_ADC0_SampleADC()
{
	
	/*******Supported Devices******************************************************************
	// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
	// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
	// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
	// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
	// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
	// 18F4680, 18F4682, 18F4685
	******************************************************************************************/

	#ifndef MX_MIAC

		#define MX_ADC_CHANNEL		12
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		0

		//set up ADC conversion
		char old_tris, cnt;
		adcon2 = MX_ADC_CONV_SP & 0x07;

		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x0E;
		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x0D;
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x0C;
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x08
			adcon1 = 0x0B;
			#if (MX_ADC_VREF_OPT != 0)
				#error "Target device is currently using AN3 for VREF+"
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x20
			adcon1 = 0x0A;
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x09;
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x08;
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x07;
		#endif
		#if (MX_ADC_CHANNEL == 8)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x06;
		#endif
		#if (MX_ADC_CHANNEL == 9)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x05;
		#endif
		#if (MX_ADC_CHANNEL == 10)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x04;
		#endif
		#if (MX_ADC_CHANNEL == 11)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x03;
		#endif
		#if (MX_ADC_CHANNEL == 12)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x02;
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#error "ADC Type 13 conversion code error - please contact technical support"
		#endif

		//assign VREF functionality
		#if (MX_ADC_VREF_OPT != 0)
			st_bit(adcon1, VCFG0);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;

		//turn ADC on
		adcon0 = 0x01 | (MX_ADC_CHANNEL << 2);

		//wait the acquisition time
		cnt = 0;
		while (cnt < MX_ADC_SAMP_TIME) cnt++;

		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x02;
		while (adcon0 & 0x02);

		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
		adcon1 = 0x0f;
		adcon0 = 0x00;

		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CHANNEL
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

	#endif

}

char FCD_ADC0_ReadAsByte()
{
	
	#ifdef MX_MIAC_SYSTEM
		int iSample;

		iSample = FCD_ADC0_ReadAsInt();

		return (iSample >> 2);
	#else

		FCD_ADC0_SampleADC();

		return adresh;
	#endif

}

short FCD_ADC0_ReadAsInt()
{
	
		short iRetVal;

	#ifdef MX_MIAC_SYSTEM

	  #if (0 == MX_MIAC_MM_MIAC_BASE)
	  	iRetVal = MIAC_Master_InputANA10(12);
	  #else
		unsigned int ModID = ((0 << 5) + 0) << 9;

		MIAC_CAN_TX[0] = 12;

		MIAC_Module_WR(ModID, 289, 1,1,0);
		MIAC_Module_GetAck(ModID + 32, 289, 200);
		iRetVal = ((MIAC_CAN_RX[0] << 8) | MIAC_CAN_RX[1]) >> 2;
	  #endif
	#else
		FCD_ADC0_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);
	#endif
		return (iRetVal);

}

float FCD_ADC0_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC0_ReadAsInt();											//Read as 10-bit Integer

		fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
		fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
		fSample = float32_from_int32(iSample);							//Convert to floating point variable
		fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC0_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC0_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//ADC(2): //Implémentations Macro


void FCD_ADC2_SampleADC()

{
	
	/*******Supported Devices******************************************************************
	// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
	// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
	// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
	// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
	// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
	// 18F4680, 18F4682, 18F4685
	******************************************************************************************/

	#ifndef MX_MIAC

		#define MX_ADC_CHANNEL		9
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		0

		//set up ADC conversion
		char old_tris, cnt;
		adcon2 = MX_ADC_CONV_SP & 0x07;
08C8  0E03      	MOVLW 0x03
08CA  6EC0      	MOVWF gbl_adcon2


		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x0E;
		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x0D;
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x0C;
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x08
			adcon1 = 0x0B;
			#if (MX_ADC_VREF_OPT != 0)
				#error "Target device is currently using AN3 for VREF+"
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x20
			adcon1 = 0x0A;
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x09;
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x08;
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x07;
		#endif
		#if (MX_ADC_CHANNEL == 8)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x06;
		#endif
		#if (MX_ADC_CHANNEL == 9)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x05;
08CC  0E05      	MOVLW 0x05
08CE  6EC1      	MOVWF gbl_adcon1

		#endif
		#if (MX_ADC_CHANNEL == 10)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x04;
		#endif
		#if (MX_ADC_CHANNEL == 11)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x03;
		#endif
		#if (MX_ADC_CHANNEL == 12)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x02;
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#error "ADC Type 13 conversion code error - please contact technical support"
		#endif

		//assign VREF functionality
		#if (MX_ADC_VREF_OPT != 0)
			st_bit(adcon1, VCFG0);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
08D0  5093      	MOVF gbl_trisb, W
08D2  6E3A      	MOVWF FCD_ADC2_S_00050_1_old_tris

		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;
08D4  0E10      	MOVLW 0x10
08D6  1093      	IORWF gbl_trisb, W
08D8  6E93      	MOVWF gbl_trisb


		//turn ADC on
		adcon0 = 0x01 | (MX_ADC_CHANNEL << 2);
08DA  0E25      	MOVLW 0x25
08DC  6EC2      	MOVWF gbl_adcon0


		//wait the acquisition time
		cnt = 0;
08DE  6A3B      	CLRF FCD_ADC2_S_00050_1_cnt

		while (cnt < MX_ADC_SAMP_TIME) cnt++;
08E0            label6
08E0  0E28      	MOVLW 0x28
08E2  603B      	CPFSLT FCD_ADC2_S_00050_1_cnt
08E4  D002      	BRA	label7
08E6  2A3B      	INCF FCD_ADC2_S_00050_1_cnt, F
08E8  D7FB      	BRA	label6
08EA            label7


		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x02;
08EA  0E02      	MOVLW 0x02
08EC  10C2      	IORWF gbl_adcon0, W
08EE  6EC2      	MOVWF gbl_adcon0

		while (adcon0 & 0x02);
08F0            label8
08F0  B2C2      	BTFSC gbl_adcon0,1
08F2  D7FE      	BRA	label8


		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
08F4  503A      	MOVF FCD_ADC2_S_00050_1_old_tris, W
08F6  6E93      	MOVWF gbl_trisb

		adcon1 = 0x0f;
08F8  0E0F      	MOVLW 0x0F
08FA  6EC1      	MOVWF gbl_adcon1

		adcon0 = 0x00;
08FC  6AC2      	CLRF gbl_adcon0


		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CHANNEL
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

	#endif

}
08FE  0012      	RETURN


char FCD_ADC2_ReadAsByte()

{
	
	#ifdef MX_MIAC_SYSTEM
		int iSample;

		iSample = FCD_ADC2_ReadAsInt();

		return (iSample >> 2);
	#else

		FCD_ADC2_SampleADC();
090A  EC64F004  	CALL FCD_ADC2_S_00050


		return adresh;
090E  50C4      	MOVF gbl_adresh, W
0910  6E3A      	MOVWF CompTempVarRet2290

	#endif

}
0912  0012      	RETURN


short FCD_ADC2_ReadAsInt()
{
	
		short iRetVal;

	#ifdef MX_MIAC_SYSTEM

	  #if (0 == MX_MIAC_MM_MIAC_BASE)
	  	iRetVal = MIAC_Master_InputANA10(9);
	  #else
		unsigned int ModID = ((0 << 5) + 0) << 9;

		MIAC_CAN_TX[0] = 9;

		MIAC_Module_WR(ModID, 289, 1,1,0);
		MIAC_Module_GetAck(ModID + 32, 289, 200);
		iRetVal = ((MIAC_CAN_RX[0] << 8) | MIAC_CAN_RX[1]) >> 2;
	  #endif
	#else
		FCD_ADC2_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);
	#endif
		return (iRetVal);

}

float FCD_ADC2_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC2_ReadAsInt();											//Read as 10-bit Integer

		fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
		fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
		fSample = float32_from_int32(iSample);							//Convert to floating point variable
		fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC2_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC2_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//ADC(3): //Implémentations Macro


void FCD_ADC3_SampleADC()

{
	
	/*******Supported Devices******************************************************************
	// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
	// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
	// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
	// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
	// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
	// 18F4680, 18F4682, 18F4685
	******************************************************************************************/

	#ifndef MX_MIAC

		#define MX_ADC_CHANNEL		9
		#define MX_ADC_SAMP_TIME 	40
		#define MX_ADC_CONV_SP		3
		#define MX_ADC_VREF_OPT		0

		//set up ADC conversion
		char old_tris, cnt;
		adcon2 = MX_ADC_CONV_SP & 0x07;
0890  0E03      	MOVLW 0x03
0892  6EC0      	MOVWF gbl_adcon2


		//find appropriate bit
		#if (MX_ADC_CHANNEL == 0)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x0E;
		#endif
		#if (MX_ADC_CHANNEL == 1)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x0D;
		#endif
		#if (MX_ADC_CHANNEL == 2)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x0C;
		#endif
		#if (MX_ADC_CHANNEL == 3)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x08
			adcon1 = 0x0B;
			#if (MX_ADC_VREF_OPT != 0)
				#error "Target device is currently using AN3 for VREF+"
			#endif
		#endif
		#if (MX_ADC_CHANNEL == 4)
			#define MX_ADC_TRIS_REG  trisa
			#define MX_ADC_TRIS_MSK  0x20
			adcon1 = 0x0A;
		#endif
		#if (MX_ADC_CHANNEL == 5)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x09;
		#endif
		#if (MX_ADC_CHANNEL == 6)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x08;
		#endif
		#if (MX_ADC_CHANNEL == 7)
			#define MX_ADC_TRIS_REG  trise
			#define MX_ADC_TRIS_MSK  0x04
			adcon1 = 0x07;
		#endif
		#if (MX_ADC_CHANNEL == 8)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x06;
		#endif
		#if (MX_ADC_CHANNEL == 9)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x05;
0894  0E05      	MOVLW 0x05
0896  6EC1      	MOVWF gbl_adcon1

		#endif
		#if (MX_ADC_CHANNEL == 10)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x02
			adcon1 = 0x04;
		#endif
		#if (MX_ADC_CHANNEL == 11)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x10
			adcon1 = 0x03;
		#endif
		#if (MX_ADC_CHANNEL == 12)
			#define MX_ADC_TRIS_REG  trisb
			#define MX_ADC_TRIS_MSK  0x01
			adcon1 = 0x02;
		#endif

		//sanity check
		#ifndef MX_ADC_TRIS_REG
			#error "ADC Type 13 conversion code error - please contact technical support"
		#endif

		//assign VREF functionality
		#if (MX_ADC_VREF_OPT != 0)
			st_bit(adcon1, VCFG0);
		#endif

		//store old tris value, and set the i/o pin as an input
		old_tris = MX_ADC_TRIS_REG;
0898  5093      	MOVF gbl_trisb, W
089A  6E3A      	MOVWF FCD_ADC3_S_00055_1_old_tris

		MX_ADC_TRIS_REG = MX_ADC_TRIS_REG | MX_ADC_TRIS_MSK;
089C  0E10      	MOVLW 0x10
089E  1093      	IORWF gbl_trisb, W
08A0  6E93      	MOVWF gbl_trisb


		//turn ADC on
		adcon0 = 0x01 | (MX_ADC_CHANNEL << 2);
08A2  0E25      	MOVLW 0x25
08A4  6EC2      	MOVWF gbl_adcon0


		//wait the acquisition time
		cnt = 0;
08A6  6A3B      	CLRF FCD_ADC3_S_00055_1_cnt

		while (cnt < MX_ADC_SAMP_TIME) cnt++;
08A8            label3
08A8  0E28      	MOVLW 0x28
08AA  603B      	CPFSLT FCD_ADC3_S_00055_1_cnt
08AC  D002      	BRA	label4
08AE  2A3B      	INCF FCD_ADC3_S_00055_1_cnt, F
08B0  D7FB      	BRA	label3
08B2            label4


		//begin conversion and wait until it has finished
		adcon0 = adcon0 | 0x02;
08B2  0E02      	MOVLW 0x02
08B4  10C2      	IORWF gbl_adcon0, W
08B6  6EC2      	MOVWF gbl_adcon0

		while (adcon0 & 0x02);
08B8            label5
08B8  B2C2      	BTFSC gbl_adcon0,1
08BA  D7FE      	BRA	label5


		//restore old tris value, and reset adc registers
		MX_ADC_TRIS_REG = old_tris;
08BC  503A      	MOVF FCD_ADC3_S_00055_1_old_tris, W
08BE  6E93      	MOVWF gbl_trisb

		adcon1 = 0x0f;
08C0  0E0F      	MOVLW 0x0F
08C2  6EC1      	MOVWF gbl_adcon1

		adcon0 = 0x00;
08C4  6AC2      	CLRF gbl_adcon0


		#undef MX_ADC_TRIS_REG
		#undef MX_ADC_TRIS_MSK
		#undef MX_ADC_SAMP_TIME
		#undef MX_ADC_CHANNEL
		#undef MX_ADC_CONV_SP
		#undef MX_ADC_VREF_OPT

	#endif

}
08C6  0012      	RETURN


char FCD_ADC3_ReadAsByte()

{
	
	#ifdef MX_MIAC_SYSTEM
		int iSample;

		iSample = FCD_ADC3_ReadAsInt();

		return (iSample >> 2);
	#else

		FCD_ADC3_SampleADC();
0900  EC48F004  	CALL FCD_ADC3_S_00055


		return adresh;
0904  50C4      	MOVF gbl_adresh, W
0906  6E3A      	MOVWF CompTempVarRet2291

	#endif

}
0908  0012      	RETURN


short FCD_ADC3_ReadAsInt()
{
	
		short iRetVal;

	#ifdef MX_MIAC_SYSTEM

	  #if (0 == MX_MIAC_MM_MIAC_BASE)
	  	iRetVal = MIAC_Master_InputANA10(9);
	  #else
		unsigned int ModID = ((0 << 5) + 0) << 9;

		MIAC_CAN_TX[0] = 9;

		MIAC_Module_WR(ModID, 289, 1,1,0);
		MIAC_Module_GetAck(ModID + 32, 289, 200);
		iRetVal = ((MIAC_CAN_RX[0] << 8) | MIAC_CAN_RX[1]) >> 2;
	  #endif
	#else
		FCD_ADC3_SampleADC();

		iRetVal = (adresh << 2);
		iRetVal = iRetVal | (adresl >> 6);
	#endif
		return (iRetVal);

}

float FCD_ADC3_ReadAsVoltage()
{
	

		int iSample;
		float fSample, fVoltage, fVperDiv;

		#define MX_ADC_VREF_V		500

		iSample = FCD_ADC3_ReadAsInt();											//Read as 10-bit Integer

		fVoltage = float32_from_int32(MX_ADC_VREF_V);					//Convert reference voltage count to floating point (0 - 500 x 10mV)
		fVoltage = float32_mul(fVoltage, 0.01);							//Convert reference voltage count to actual voltage (0 - 5)
		fVperDiv = float32_mul(fVoltage, 0.000976);						//Convert actual voltage to voltage per division (VRef / 1024)
		fSample = float32_from_int32(iSample);							//Convert to floating point variable
		fVoltage = float32_mul(fSample, fVperDiv);						//Calculate floating point voltage

		#undef MX_ADC_VREF_V
		return (fVoltage);

}

void FCD_ADC3_ReadAsString(char* FCR_RETVAL, char FCR_RETVAL_SIZE)
{
	
		float fVoltage;

		fVoltage = FCD_ADC3_ReadAsVoltage();
		FCI_FLOAT_TO_STRING(fVoltage, 2, FCR_RETVAL, FCR_RETVAL_SIZE);	//Convert to String

}



//Stepper(0): //Implémentations Macro


void FCD_Stepper0_IncrementStep()

{
	
	#ifdef MX_MIAC_SYSTEM
	  #if (portd != MX_MIAC_MM_MIAC_BASE)

		unsigned int ModID = ((trisd << 5) + portd) << 9;
	  #endif
	#endif

		char pattern_now;

		if( Stepper_263108_enabled)
09B0  5235      	MOVF gbl_Stepper_263108_enabled, F
09B2  B4D8      	BTFSC STATUS,Z

		{
			Stepper_263108_phase = (Stepper_263108_phase + MX_Stepper_263108_INC_STEP);	//increment step
09B6  2834      	INCF gbl_Stepper_263108_phase, W
09B8  6E34      	MOVWF gbl_Stepper_263108_phase


			#if (MX_Stepper_263108_STEP_TYPE == 1)
				Stepper_263108_phase &=0x06;		//full step, even index
			#endif

			#if (MX_Stepper_263108_STEP_TYPE == 2)								//full step, odd index
				Stepper_263108_phase |=0x01;
			#endif

			Stepper_263108_phase &= 0x07;
09BA  0E07      	MOVLW 0x07
09BC  1634      	ANDWF gbl_Stepper_263108_phase, F

			pattern_now = Stepper_263108_pattern[Stepper_263108_phase];
09BE  EE00F005  	LFSR 0x00, gbl_Stepper_263108_pattern
09C2  50E9      	MOVF FSR0L, W
09C4  5034      	MOVF gbl_Stepper_263108_phase, W
09C6  26E9      	ADDWF FSR0L, F
09C8  50EF      	MOVF INDF0, W
09CA  6E36      	MOVWF FCD_Steppe_0005A_1_pattern_now



		  #ifdef MX_MIAC_SYSTEM
	  		#if (portd != MX_MIAC_MM_MIAC_BASE)
				MIAC_CAN_TX[0] = 0;
				MIAC_CAN_TX[1] = 1;
				MIAC_CAN_TX[2] = 2;
				MIAC_CAN_TX[3] = 7;
				MIAC_CAN_TX[4] = pattern_now;
				MIAC_Module_WR(ModID, 512, 5,1,0);
				MIAC_Module_GetAck(ModID + 32, 512, 20);
			#else
				if(test_bit(pattern_now, 0))
				{
					if(0 > 12)
						FCD_MIAC0_OutputON(0 - 12);
					else
						FCD_MIAC0_RelayON(0 - 8);
				}else{
					if(0 > 12)
						FCD_MIAC0_OutputOFF(0 - 12);
					else
						FCD_MIAC0_RelayOFF(0 - 8);
				}

				if(test_bit(pattern_now, 1))
				{
					if(1 > 12)
						FCD_MIAC0_OutputON(1 - 12);
					else
						FCD_MIAC0_RelayON(1 - 8);
				}else{
					if(1 > 12)
						FCD_MIAC0_OutputOFF(1 - 12);
					else
						FCD_MIAC0_RelayOFF(1 - 8);
				}

				if(test_bit(pattern_now, 2))
				{
					if(2 > 12)
						FCD_MIAC0_OutputON(2 - 12);
					else
						FCD_MIAC0_RelayON(2 - 8);
				}else{
					if(2 > 12)
						FCD_MIAC0_OutputOFF(2 - 12);
					else
						FCD_MIAC0_RelayOFF(2 - 8);
				}

				if(test_bit(pattern_now, 3))
				{
					if(7 > 12)
						FCD_MIAC0_OutputON(7 - 12);
					else
						FCD_MIAC0_RelayON(7 - 8);
				}else{
					if(7 > 12)
						FCD_MIAC0_OutputOFF(7 - 12);
					else
						FCD_MIAC0_RelayOFF(7 - 8);
				}
	  		#endif
		  #else
			if(test_bit(pattern_now, 0)) set_bit (MX_Stepper_263108_PORT1, MX_Stepper_263108_PIN1);
09CC  A036      	BTFSS FCD_Steppe_0005A_1_pattern_now,0
09CE  D002      	BRA	label22
09D0  8083      	BSF gbl_portd,0
09D4            label22

			else clear_bit (MX_Stepper_263108_PORT1, MX_Stepper_263108_PIN1);
09D2  D001      	BRA	label23
09D4  9083      	BCF gbl_portd,0
09D6            label23

			if(test_bit(pattern_now, 1)) set_bit (MX_Stepper_263108_PORT2, MX_Stepper_263108_PIN2);
09D6  A236      	BTFSS FCD_Steppe_0005A_1_pattern_now,1
09D8  D002      	BRA	label24
09DA  8283      	BSF gbl_portd,1
09DE            label24

			else clear_bit (MX_Stepper_263108_PORT2, MX_Stepper_263108_PIN2);
09DC  D001      	BRA	label25
09DE  9283      	BCF gbl_portd,1
09E0            label25

			if(test_bit(pattern_now, 2)) set_bit (MX_Stepper_263108_PORT3, MX_Stepper_263108_PIN3);
09E0  A436      	BTFSS FCD_Steppe_0005A_1_pattern_now,2
09E2  D002      	BRA	label26
09E4  8483      	BSF gbl_portd,2
09E8            label26

			else clear_bit (MX_Stepper_263108_PORT3, MX_Stepper_263108_PIN3);
09E6  D001      	BRA	label27
09E8  9483      	BCF gbl_portd,2
09EA            label27

			if(test_bit(pattern_now, 3)) set_bit (MX_Stepper_263108_PORT4, MX_Stepper_263108_PIN4);
09EA  A636      	BTFSS FCD_Steppe_0005A_1_pattern_now,3
09EC  D002      	BRA	label28
09EE  8E83      	BSF gbl_portd,7
09F2            label28

			else clear_bit (MX_Stepper_263108_PORT4, MX_Stepper_263108_PIN4);
09F2  9E83      	BCF gbl_portd,7

		  #endif
		}
}
09B4  0012      	RETURN
09F0  0012      	RETURN
09F4  0012      	RETURN


void FCD_Stepper0_DecrementStep()
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if (portd != MX_MIAC_MM_MIAC_BASE)

		unsigned int ModID = ((trisd << 5) + portd) << 9;
	  #endif
	#endif
		char pattern_now;

		if( Stepper_263108_enabled)
		{

			Stepper_263108_phase = (Stepper_263108_phase - MX_Stepper_263108_INC_STEP);	//increment step

			#if (MX_Stepper_263108_STEP_TYPE == 1)
				Stepper_263108_phase &=0x06;		//full step, even index
			#endif

			#if (MX_Stepper_263108_STEP_TYPE == 2)			//full step, odd index
				Stepper_263108_phase |=0x01;
			#endif

			Stepper_263108_phase &= 0x07;
			pattern_now = Stepper_263108_pattern[Stepper_263108_phase];

		  #ifdef MX_MIAC_SYSTEM
	  		#if (portd != MX_MIAC_MM_MIAC_BASE)
				MIAC_CAN_TX[0] = 0;
				MIAC_CAN_TX[1] = 1;
				MIAC_CAN_TX[2] = 2;
				MIAC_CAN_TX[3] = 7;
				MIAC_CAN_TX[4] = pattern_now;
				MIAC_Module_WR(ModID, 512, 5,1,0);
				MIAC_Module_GetAck(ModID + 32, 512, 20);
			#else
				if(test_bit(pattern_now, 0))
				{
					if(0 > 12)
						FCD_MIAC0_OutputON(0 - 12);
					else
						FCD_MIAC0_RelayON(0 - 8);
				}else{
					if(0 > 12)
						FCD_MIAC0_OutputOFF(0 - 12);
					else
						FCD_MIAC0_RelayOFF(0 - 8);
				}

				if(test_bit(pattern_now, 1))
				{
					if(1 > 12)
						FCD_MIAC0_OutputON(1 - 12);
					else
						FCD_MIAC0_RelayON(1 - 8);
				}else{
					if(1 > 12)
						FCD_MIAC0_OutputOFF(1 - 12);
					else
						FCD_MIAC0_RelayOFF(1 - 8);
				}

				if(test_bit(pattern_now, 2))
				{
					if(2 > 12)
						FCD_MIAC0_OutputON(2 - 12);
					else
						FCD_MIAC0_RelayON(2 - 8);
				}else{
					if(2 > 12)
						FCD_MIAC0_OutputOFF(2 - 12);
					else
						FCD_MIAC0_RelayOFF(2 - 8);
				}

				if(test_bit(pattern_now, 3))
				{
					if(7 > 12)
						FCD_MIAC0_OutputON(7 - 12);
					else
						FCD_MIAC0_RelayON(7 - 8);
				}else{
					if(7 > 12)
						FCD_MIAC0_OutputOFF(7 - 12);
					else
						FCD_MIAC0_RelayOFF(7 - 8);
				}

	  		#endif
		  #else
			if(test_bit(pattern_now, 0)) set_bit (MX_Stepper_263108_PORT1, MX_Stepper_263108_PIN1);
			else clear_bit (MX_Stepper_263108_PORT1, MX_Stepper_263108_PIN1);
			if(test_bit(pattern_now, 1)) set_bit (MX_Stepper_263108_PORT2, MX_Stepper_263108_PIN2);
			else clear_bit (MX_Stepper_263108_PORT2, MX_Stepper_263108_PIN2);
			if(test_bit(pattern_now, 2)) set_bit (MX_Stepper_263108_PORT3, MX_Stepper_263108_PIN3);
			else clear_bit (MX_Stepper_263108_PORT3, MX_Stepper_263108_PIN3);
			if(test_bit(pattern_now, 3)) set_bit (MX_Stepper_263108_PORT4, MX_Stepper_263108_PIN4);
			else clear_bit (MX_Stepper_263108_PORT4, MX_Stepper_263108_PIN4);
		  #endif
		}
}

void FCD_Stepper0_EnableMotor()

{
	
	#ifdef MX_MIAC_SYSTEM
	  #if (portd != MX_MIAC_MM_MIAC_BASE)

		unsigned int ModID = ((trisd << 5) + portd) << 9;
	  #endif
	#endif

		Stepper_263108_enabled = 1;
099A  0E01      	MOVLW 0x01
099C  6E35      	MOVWF gbl_Stepper_263108_enabled


	  #ifdef MX_MIAC_SYSTEM
		#if (portd != MX_MIAC_MM_MIAC_BASE)
			MIAC_CAN_TX[0] = 0;
			MIAC_CAN_TX[1] = 1;
			MIAC_CAN_TX[2] = 2;
			MIAC_CAN_TX[3] = 7;
			MIAC_CAN_TX[4] = 0;
			MIAC_Module_WR(ModID, 512, 5,1,0);
			MIAC_Module_GetAck(ModID + 32, 512, 20);
		#else
			if(0 > 12)
				FCD_MIAC0_OutputOFF(0 - 12);
			else
				FCD_MIAC0_RelayOFF(0 - 8);

			if(1 > 12)
				FCD_MIAC0_OutputOFF(1 - 12);
			else
				FCD_MIAC0_RelayOFF(1 - 8);

			if(2 > 12)
				FCD_MIAC0_OutputOFF(2 - 12);
			else
				FCD_MIAC0_RelayOFF(2 - 8);

			if(7 > 12)
				FCD_MIAC0_OutputOFF(7 - 12);
			else
				FCD_MIAC0_RelayOFF(7 - 8);
		#endif
	  #else
		clear_bit(MX_Stepper_263108_TRIS1, MX_Stepper_263108_PIN1);
099E  9095      	BCF gbl_trisd,0

		clear_bit(MX_Stepper_263108_PORT1, MX_Stepper_263108_PIN1);
09A0  9083      	BCF gbl_portd,0

		clear_bit(MX_Stepper_263108_TRIS2, MX_Stepper_263108_PIN2);
09A2  9295      	BCF gbl_trisd,1

		clear_bit(MX_Stepper_263108_PORT2, MX_Stepper_263108_PIN2);
09A4  9283      	BCF gbl_portd,1

		clear_bit(MX_Stepper_263108_TRIS3, MX_Stepper_263108_PIN3);
09A6  9495      	BCF gbl_trisd,2

		clear_bit(MX_Stepper_263108_PORT3, MX_Stepper_263108_PIN3);
09A8  9483      	BCF gbl_portd,2

		clear_bit(MX_Stepper_263108_TRIS4, MX_Stepper_263108_PIN4);
09AA  9E95      	BCF gbl_trisd,7

		clear_bit(MX_Stepper_263108_PORT4, MX_Stepper_263108_PIN4);
09AC  9E83      	BCF gbl_portd,7

	  #endif

}
09AE  0012      	RETURN


void FCD_Stepper0_DisableMotor()
{
	
	#ifdef MX_MIAC_SYSTEM
	  #if (portd != MX_MIAC_MM_MIAC_BASE)

		unsigned int ModID = ((trisd << 5) + portd) << 9;
	  #endif
	#endif

	  #ifdef MX_MIAC_SYSTEM
		#if (portd != MX_MIAC_MM_MIAC_BASE)
			MIAC_CAN_TX[0] = 0;
			MIAC_CAN_TX[1] = 1;
			MIAC_CAN_TX[2] = 2;
			MIAC_CAN_TX[3] = 7;
			MIAC_Module_WR(ModID, 513, 4,1,0);
			MIAC_Module_GetAck(ModID + 32, 513, 20);
		#else
			if(0 > 12)
				FCD_MIAC0_OutputOFF(0 - 12);
			else
				FCD_MIAC0_RelayOFF(0 - 8);

			if(1 > 12)
				FCD_MIAC0_OutputOFF(1 - 12);
			else
				FCD_MIAC0_RelayOFF(1 - 8);

			if(2 > 12)
				FCD_MIAC0_OutputOFF(2 - 12);
			else
				FCD_MIAC0_RelayOFF(2 - 8);

			if(7 > 12)
				FCD_MIAC0_OutputOFF(7 - 12);
			else
				FCD_MIAC0_RelayOFF(7 - 8);
		#endif
	  #else
		Stepper_263108_enabled = 0;
		set_bit(MX_Stepper_263108_TRIS1, MX_Stepper_263108_PIN1);
		clear_bit(MX_Stepper_263108_PORT1, MX_Stepper_263108_PIN1);
		set_bit(MX_Stepper_263108_TRIS2, MX_Stepper_263108_PIN2);
		clear_bit(MX_Stepper_263108_PORT2, MX_Stepper_263108_PIN2);
		set_bit(MX_Stepper_263108_TRIS3, MX_Stepper_263108_PIN3);
		clear_bit(MX_Stepper_263108_PORT3, MX_Stepper_263108_PIN3);
		set_bit(MX_Stepper_263108_TRIS4, MX_Stepper_263108_PIN4);
		clear_bit(MX_Stepper_263108_PORT4, MX_Stepper_263108_PIN4);
	  #endif
}

//Implémentations Macro

void FCM_initLed()
{
	
	//Définitions des variables locales
	char FCL_I;

	//Calcul
	//Calcul:
	//  initLed.i = 1
	FCL_I = 1;
	

	//Boucle
	//Boucle: Boucle 8 fois
	for (FCLV_LOOP1=0; FCLV_LOOP1<8; FCLV_LOOP1++)
	{
		//Sortie
		//Sortie: initLed.i -> PORTD
		trisd = 0x00;
		portd = FCL_I;


		//Pause
		//Pause: 100 ms
		delay_ms(100);


		//Sortie
		//Sortie: 0 -> PORTD
		trisd = 0x00;
		portd = 0;


		//Calcul
		//Calcul:
		//  initLed.i = initLed.i * 2
		FCL_I = FCL_I * 2;
		

	}


	//Calcul
	//Calcul:
	//  initLed.i = 128
	FCL_I = 128;
	

	//Boucle
	//Boucle: Boucle 8 fois
	for (FCLV_LOOP2=0; FCLV_LOOP2<8; FCLV_LOOP2++)
	{
		//Sortie
		//Sortie: initLed.i -> PORTD
		trisd = 0x00;
		portd = FCL_I;


		//Pause
		//Pause: 100 ms
		delay_ms(100);


		//Sortie
		//Sortie: 0 -> PORTD
		trisd = 0x00;
		portd = 0;


		//Calcul
		//Calcul:
		//  initLed.i = initLed.i / 2
		FCL_I = FCL_I / 2;
		

	}


}

void FCM_showLevel(char FCL_LEVEL)
{
	
	//Définitions des variables locales
	char FCL_BATLEVEL;

	//Décision
	//Décision: showLevel.level > 0?
	if (FCL_LEVEL > 0)
	{
		//Sortie
		//Sortie: 1 -> D0
		trisd = trisd & 0xfe;
		if (1)
			portd = (portd & 0xfe) | 0x01;
		else
			portd = portd & 0xfe;


	} else {
		//Sortie
		//Sortie: 0 -> D0
		trisd = trisd & 0xfe;
		if (0)
			portd = (portd & 0xfe) | 0x01;
		else
			portd = portd & 0xfe;


	}


	//Décision
	//Décision: showLevel.level > 36?
	if (FCL_LEVEL > 36)
	{
		//Sortie
		//Sortie: 1 -> D1
		trisd = trisd & 0xfd;
		if (1)
			portd = (portd & 0xfd) | 0x02;
		else
			portd = portd & 0xfd;


	} else {
		//Sortie
		//Sortie: 0 -> D1
		trisd = trisd & 0xfd;
		if (0)
			portd = (portd & 0xfd) | 0x02;
		else
			portd = portd & 0xfd;


	}


	//Décision
	//Décision: showLevel.level > 72?
	if (FCL_LEVEL > 72)
	{
		//Sortie
		//Sortie: 1 -> D2
		trisd = trisd & 0xfb;
		if (1)
			portd = (portd & 0xfb) | 0x04;
		else
			portd = portd & 0xfb;


	} else {
		//Sortie
		//Sortie: 0 -> D2
		trisd = trisd & 0xfb;
		if (0)
			portd = (portd & 0xfb) | 0x04;
		else
			portd = portd & 0xfb;


	}


	//Décision
	//Décision: showLevel.level > 108?
	if (FCL_LEVEL > 108)
	{
		//Sortie
		//Sortie: 1 -> D3
		trisd = trisd & 0xf7;
		if (1)
			portd = (portd & 0xf7) | 0x08;
		else
			portd = portd & 0xf7;


	} else {
		//Sortie
		//Sortie: 0 -> D3
		trisd = trisd & 0xf7;
		if (0)
			portd = (portd & 0xf7) | 0x08;
		else
			portd = portd & 0xf7;


	}


	//Décision
	//Décision: showLevel.level > 145?
	if (FCL_LEVEL > 145)
	{
		//Sortie
		//Sortie: 1 -> D4
		trisd = trisd & 0xef;
		if (1)
			portd = (portd & 0xef) | 0x10;
		else
			portd = portd & 0xef;


	} else {
		//Sortie
		//Sortie: 0 -> D4
		trisd = trisd & 0xef;
		if (0)
			portd = (portd & 0xef) | 0x10;
		else
			portd = portd & 0xef;


	}


	//Décision
	//Décision: showLevel.level > 181?
	if (FCL_LEVEL > 181)
	{
		//Sortie
		//Sortie: 1 -> D5
		trisd = trisd & 0xdf;
		if (1)
			portd = (portd & 0xdf) | 0x20;
		else
			portd = portd & 0xdf;


	} else {
		//Sortie
		//Sortie: 0 -> D5
		trisd = trisd & 0xdf;
		if (0)
			portd = (portd & 0xdf) | 0x20;
		else
			portd = portd & 0xdf;


	}


	//Décision
	//Décision: showLevel.level > 217?
	if (FCL_LEVEL > 217)
	{
		//Sortie
		//Sortie: 1 -> D6
		trisd = trisd & 0xbf;
		if (1)
			portd = (portd & 0xbf) | 0x40;
		else
			portd = portd & 0xbf;


	} else {
		//Sortie
		//Sortie: 0 -> D6
		trisd = trisd & 0xbf;
		if (0)
			portd = (portd & 0xbf) | 0x40;
		else
			portd = portd & 0xbf;


	}


	//Décision
	//Décision: showLevel.level > 254?
	if (FCL_LEVEL > 254)
	{
		//Sortie
		//Sortie: 1 -> D7
		trisd = trisd & 0x7f;
		if (1)
			portd = (portd & 0x7f) | 0x80;
		else
			portd = portd & 0x7f;


	} else {
		//Sortie
		//Sortie: 0 -> D7
		trisd = trisd & 0x7f;
		if (0)
			portd = (portd & 0x7f) | 0x80;
		else
			portd = portd & 0x7f;


	}


}

char FCM_isBattLevelOK(char FCL_PRCT)
{
	
	//Définitions des variables locales
	char FCL_BATTLEVEL;

	char FCR_RETVAL;

	//Appel d'une Macro
	//Appel d'une Macro: isBattLevelOK.battLevel=getBat
	FCL_BATTLEVEL = FCM_getBat();


	//Décision
	//Décision: isBattLevelOK.battLevel >= isBattLevelOK.prct?
	if (FCL_BATTLEVEL >= FCL_PRCT)
	{
		//Calcul
		//Calcul:
		//  isBattLevelOK.Return = true
		FCR_RETVAL = FCV_TRUE;
		

	} else {
		//Calcul
		//Calcul:
		//  isBattLevelOK.Return = false
		FCR_RETVAL = FCV_FALSE;
		

	}


	return (FCR_RETVAL);
}

char FCM_getBat()
{
	
	char FCR_RETVAL;

	//Appel de la Routine Composant
	//Appel de la Routine Composant: getBat.Return=ADC(0)::Lire_comme_Octet
	FCR_RETVAL = FCD_ADC0_ReadAsByte();


	return (FCR_RETVAL);
}

char FCM_getTrou(short FCL_TIMEOUT)
{
	
	//Définitions des variables locales
	short FCL_T;
	char FCL_CAPT;

	char FCR_RETVAL;

	//Calcul
	//Calcul:
	//  getTrou.Return = false
	//  getTrou.t = 0
	FCR_RETVAL = FCV_FALSE;
	FCL_T = 0;
	

	//Boucle
	//Boucle: Tant que getTrou.t < getTrou.timeout && getTrou.Return == false
	while (1)
	{
		//Appel d'une Macro
		//Appel d'une Macro: getTrou.capt=getTrouState(1)
		FCL_CAPT = FCM_getTrouState(1);


		//Décision
		//Décision: getTrou.capt?
		if (FCL_CAPT)
		{
			//Calcul
			//Calcul:
			//  getTrou.Return = true
			FCR_RETVAL = FCV_TRUE;
			

		}


		//Appel d'une Macro
		//Appel d'une Macro: getTrou.capt=getTrouState(2)
		FCL_CAPT = FCM_getTrouState(2);


		//Décision
		//Décision: getTrou.capt?
		if (FCL_CAPT)
		{
			//Calcul
			//Calcul:
			//  getTrou.Return = true
			FCR_RETVAL = FCV_TRUE;
			

		}


		//Calcul
		//Calcul:
		//  getTrou.t = getTrou.t + 25
		FCL_T = FCL_T + 25;
		

		//Pause
		//Pause: 25 ms
		delay_ms(25);


		if ((FCL_T < FCL_TIMEOUT && FCR_RETVAL == FCV_FALSE) == 0) break;
	}


	return (FCR_RETVAL);
}

void FCM_move(short FCL_VITESSE, short FCL_SENS, short FCL_DEGRE)
{
	
	//Définitions des variables locales
	short FCL_VITMOTD;
	short FCL_VITMOTG;

	//Décision
	//Décision: move.vitesse == stop?
	if (FCL_VITESSE == FCV_STOP)
	{
		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::Disable(1)
		FCD_PWM0_Disable(1);


		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::Disable(2)
		FCD_PWM0_Disable(2);


		//Sortie
		//Sortie: 0 -> C0
		trisc = trisc & 0xfe;
		if (0)
			portc = (portc & 0xfe) | 0x01;
		else
			portc = portc & 0xfe;


		//Sortie
		//Sortie: 0 -> C7
		trisc = trisc & 0x7f;
		if (0)
			portc = (portc & 0x7f) | 0x80;
		else
			portc = portc & 0x7f;


	} else {
		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::Enable(1)
		FCD_PWM0_Enable(1);


		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::Enable(2)
		FCD_PWM0_Enable(2);


		//droit ?
		//Décision: move.degre == droit?
		if (FCL_DEGRE == FCV_DROIT)
		{
			//Décision
			//Décision: move.sens == avant?
			if (FCL_SENS == FCV_AVANT)
			{
				//Sortie
				//Sortie: 0 -> C0
				trisc = trisc & 0xfe;
				if (0)
					portc = (portc & 0xfe) | 0x01;
				else
					portc = portc & 0xfe;


				//Sortie
				//Sortie: 0 -> C7
				trisc = trisc & 0x7f;
				if (0)
					portc = (portc & 0x7f) | 0x80;
				else
					portc = portc & 0x7f;


				//Calcul
				//Calcul:
				//  move.vitMotG = move.vitesse
				//  move.vitMotD = move.vitesse
				FCL_VITMOTG = FCL_VITESSE;
				FCL_VITMOTD = FCL_VITESSE;
				

			} else {
				//Sortie
				//Sortie: 1 -> C0
				trisc = trisc & 0xfe;
				if (1)
					portc = (portc & 0xfe) | 0x01;
				else
					portc = portc & 0xfe;


				//Sortie
				//Sortie: 1 -> C7
				trisc = trisc & 0x7f;
				if (1)
					portc = (portc & 0x7f) | 0x80;
				else
					portc = portc & 0x7f;


				//Calcul
				//Calcul:
				//  move.vitMotG = 255 - move.vitesse
				//  move.vitMotD = 255 - move.vitesse
				FCL_VITMOTG = 255 - FCL_VITESSE;
				FCL_VITMOTD = 255 - FCL_VITESSE;
				

			}


		} else {
			//degre 45-90
			//Décision: move.degre > 45 && move.degre <= 90?
			if (FCL_DEGRE > 45 && FCL_DEGRE <= 90)
			{
				//Décision
				//Décision: move.sens == avant?
				if (FCL_SENS == FCV_AVANT)
				{
					//Sortie
					//Sortie: 1 -> C0
					trisc = trisc & 0xfe;
					if (1)
						portc = (portc & 0xfe) | 0x01;
					else
						portc = portc & 0xfe;


					//Sortie
					//Sortie: 0 -> C7
					trisc = trisc & 0x7f;
					if (0)
						portc = (portc & 0x7f) | 0x80;
					else
						portc = portc & 0x7f;


					//Calcul
					//Calcul:
					//  move.vitMotG = 255 - (move.vitesse * (move.degre-45))/45
					//  move.vitMotD = move.vitesse
					FCL_VITMOTG = 255 - (FCL_VITESSE * (FCL_DEGRE-45))/45;
					FCL_VITMOTD = FCL_VITESSE;
					

				} else {
					//Sortie
					//Sortie: 0 -> C0
					trisc = trisc & 0xfe;
					if (0)
						portc = (portc & 0xfe) | 0x01;
					else
						portc = portc & 0xfe;


					//Sortie
					//Sortie: 1 -> C7
					trisc = trisc & 0x7f;
					if (1)
						portc = (portc & 0x7f) | 0x80;
					else
						portc = portc & 0x7f;


					//Calcul
					//Calcul:
					//  move.vitMotG = (move.vitesse * (move.degre-45))/45
					//  move.vitMotD = 255 - move.vitesse
					FCL_VITMOTG = (FCL_VITESSE * (FCL_DEGRE-45))/45;
					FCL_VITMOTD = 255 - FCL_VITESSE;
					

				}


			} else {
				//degre 0-45
				//Décision: move.degre <= 45?
				if (FCL_DEGRE <= 45)
				{
					//Décision
					//Décision: move.sens == avant?
					if (FCL_SENS == FCV_AVANT)
					{
						//Sortie
						//Sortie: 0 -> C0
						trisc = trisc & 0xfe;
						if (0)
							portc = (portc & 0xfe) | 0x01;
						else
							portc = portc & 0xfe;


						//Sortie
						//Sortie: 0 -> C7
						trisc = trisc & 0x7f;
						if (0)
							portc = (portc & 0x7f) | 0x80;
						else
							portc = portc & 0x7f;


						//Calcul
						//Calcul:
						//  move.vitMotG = move.vitesse - (move.vitesse * move.degre)/45
						//  move.vitMotD = move.vitesse
						FCL_VITMOTG = FCL_VITESSE - (FCL_VITESSE * FCL_DEGRE)/45;
						FCL_VITMOTD = FCL_VITESSE;
						

					} else {
						//Sortie
						//Sortie: 0 -> C0
						trisc = trisc & 0xfe;
						if (0)
							portc = (portc & 0xfe) | 0x01;
						else
							portc = portc & 0xfe;


						//Sortie
						//Sortie: 1 -> C7
						trisc = trisc & 0x7f;
						if (1)
							portc = (portc & 0x7f) | 0x80;
						else
							portc = portc & 0x7f;


						//Calcul
						//Calcul:
						//  move.vitMotG = 255 - move.vitesse * (45 - move.degre)/45
						//  move.vitMotD = 255 - move.vitesse
						FCL_VITMOTG = 255 - FCL_VITESSE * (45 - FCL_DEGRE)/45;
						FCL_VITMOTD = 255 - FCL_VITESSE;
						

					}


				} else {
					//degre 165-210 => -90 - -45
					//Décision: move.degre >= 165 && move.degre < 210?
					if (FCL_DEGRE >= 165 && FCL_DEGRE < 210)
					{
						//Décision
						//Décision: move.sens == avant?
						if (FCL_SENS == FCV_AVANT)
						{
							//Sortie
							//Sortie: 0 -> C0
							trisc = trisc & 0xfe;
							if (0)
								portc = (portc & 0xfe) | 0x01;
							else
								portc = portc & 0xfe;


							//Sortie
							//Sortie: 1 -> C7
							trisc = trisc & 0x7f;
							if (1)
								portc = (portc & 0x7f) | 0x80;
							else
								portc = portc & 0x7f;


							//Calcul
							//Calcul:
							//  move.vitMotD = (move.vitesse * (move.degre - 165))/45
							//  move.vitMotG = move.vitesse
							FCL_VITMOTD = (FCL_VITESSE * (FCL_DEGRE - 165))/45;
							FCL_VITMOTG = FCL_VITESSE;
							

						} else {
							//Sortie
							//Sortie: 1 -> C0
							trisc = trisc & 0xfe;
							if (1)
								portc = (portc & 0xfe) | 0x01;
							else
								portc = portc & 0xfe;


							//Sortie
							//Sortie: 0 -> C7
							trisc = trisc & 0x7f;
							if (0)
								portc = (portc & 0x7f) | 0x80;
							else
								portc = portc & 0x7f;


							//Calcul
							//Calcul:
							//  move.vitMotD = 255 - move.vitesse * (45 + move.degre + 210)/45
							//  move.vitMotG = move.vitesse
							FCL_VITMOTD = 255 - FCL_VITESSE * (45 + FCL_DEGRE + 210)/45;
							FCL_VITMOTG = FCL_VITESSE;
							

						}


					} else {
						//degre 210-255 => -40 - 0
						//Décision: move.degre >= 210?
						if (FCL_DEGRE >= 210)
						{
							//Décision
							//Décision: move.sens == avant?
							if (FCL_SENS == FCV_AVANT)
							{
								//Sortie
								//Sortie: 0 -> C0
								trisc = trisc & 0xfe;
								if (0)
									portc = (portc & 0xfe) | 0x01;
								else
									portc = portc & 0xfe;


								//Sortie
								//Sortie: 0 -> C7
								trisc = trisc & 0x7f;
								if (0)
									portc = (portc & 0x7f) | 0x80;
								else
									portc = portc & 0x7f;


								//Calcul
								//Calcul:
								//  move.vitMotD = (move.vitesse * (move.degre - 210))/45
								//  move.vitMotG = move.vitesse
								FCL_VITMOTD = (FCL_VITESSE * (FCL_DEGRE - 210))/45;
								FCL_VITMOTG = FCL_VITESSE;
								

							} else {
								//Sortie
								//Sortie: 1 -> C0
								trisc = trisc & 0xfe;
								if (1)
									portc = (portc & 0xfe) | 0x01;
								else
									portc = portc & 0xfe;


								//Sortie
								//Sortie: 1 -> C7
								trisc = trisc & 0x7f;
								if (1)
									portc = (portc & 0x7f) | 0x80;
								else
									portc = portc & 0x7f;


								//Calcul
								//Calcul:
								//  move.vitMotD = 255 - move.vitesse * (45 + move.degre + 255)/45
								//  move.vitMotG = move.vitesse
								FCL_VITMOTD = 255 - FCL_VITESSE * (45 + FCL_DEGRE + 255)/45;
								FCL_VITMOTG = FCL_VITESSE;
								

							}


						}


					}


				}


			}


		}


		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::SetDutyCycle(1, move.vitMotG)
		FCD_PWM0_SetDutyCycle(1, FCL_VITMOTG);


		//Appel de la Routine Composant
		//Appel de la Routine Composant: PWM(0)::SetDutyCycle(2, move.vitMotD)
		FCD_PWM0_SetDutyCycle(2, FCL_VITMOTD);


	}


}

void FCM_align()
{
	
	//Définitions des variables locales
	char FCL_ETAT;

	//Entrée
	//Entrée: PORTB -> align.etat
	trisb = trisb | 0x0c;
	FCL_ETAT = portb & 0x0c;


	//Boucle
	//Boucle: Tant que align.etat == 12
	while (!(FCL_ETAT == 12))
	{
		//Appel d'une Macro
		//Appel d'une Macro: align.etat=getTrouState(0)
		FCL_ETAT = FCM_getTrouState(0);


		//Multi-Décision
		//Multi-Décision: align.etat?
		switch (FCL_ETAT)
		{
			case 4:
			{
				//Right
				//Appel d'une Macro: move(64, avant, 45)
				FCM_move(64, FCV_AVANT, 45);


				break;
			}

			case 8:
			{
				//Left
				//Appel d'une Macro: move(64, avant, -45)
				FCM_move(64, FCV_AVANT, -45);


				break;
			}

		}


	}


	//Appel d'une Macro
	//Appel d'une Macro: move(stop, avant, droit)
	FCM_move(FCV_STOP, FCV_AVANT, FCV_DROIT);


	//Boucle
	//Boucle: Tant que align.etat == 0
	while (!(FCL_ETAT == 0))
	{
		//Entrée
		//Entrée: PORTB -> align.etat
		trisb = trisb | 0x0c;
		FCL_ETAT = portb & 0x0c;


		//Multi-Décision
		//Multi-Décision: align.etat?
		switch (FCL_ETAT)
		{
			case 4:
			{
				//Left
				//Appel d'une Macro: move(64, arriere, -45)
				FCM_move(64, FCV_ARRIERE, -45);


				break;
			}

			case 8:
			{
				//Right
				//Appel d'une Macro: move(64, arriere, 45)
				FCM_move(64, FCV_ARRIERE, 45);


				break;
			}

			case 12:
			{
				//Droit
				//Appel d'une Macro: move(64, arriere, droit)
				FCM_move(64, FCV_ARRIERE, FCV_DROIT);


				break;
			}

		}


	}


	//Appel d'une Macro
	//Appel d'une Macro: move(stop, avant, droit)
	FCM_move(FCV_STOP, FCV_AVANT, FCV_DROIT);


}

void FCM_verrin(char FCL_MONTE)
{
	
	//Décision
	//Décision: verrin.monte?
	if (FCL_MONTE)
	{
		//Sortie
		//Sortie: 0 -> A4
		trisa = trisa & 0xef;
		if (0)
			porta = (porta & 0xef) | 0x10;
		else
			porta = porta & 0xef;


		//Sortie
		//Sortie: 1 -> A5
		trisa = trisa & 0xdf;
		if (1)
			porta = (porta & 0xdf) | 0x20;
		else
			porta = porta & 0xdf;


	} else {
		//Sortie
		//Sortie: 1 -> A4
		trisa = trisa & 0xef;
		if (1)
			porta = (porta & 0xef) | 0x10;
		else
			porta = porta & 0xef;


		//Sortie
		//Sortie: 0 -> A5
		trisa = trisa & 0xdf;
		if (0)
			porta = (porta & 0xdf) | 0x20;
		else
			porta = porta & 0xdf;


	}


	//Pause
	//Pause: 5 s
	delay_s(5);


	//Sortie
	//Sortie: 0 -> A4
	trisa = trisa & 0xef;
	if (0)
		porta = (porta & 0xef) | 0x10;
	else
		porta = porta & 0xef;


	//Sortie
	//Sortie: 0 -> A5
	trisa = trisa & 0xdf;
	if (0)
		porta = (porta & 0xdf) | 0x20;
	else
		porta = porta & 0xdf;


}

char FCM_getTrouState(char FCL_NB)

{
	
	//Définitions des variables locales
	char FCL_VAL;
	char FCL_TRIG;

	char FCR_RETVAL;

	//Calcul
	//Calcul:
	//  getTrouState.trig = 225
	FCL_TRIG = 225;
0914  0EE1      	MOVLW 0xE1
0916  6E38      	MOVWF FCM_getTro_00042_1_FCL_TRIG

	

	//Décision
	//Décision: getTrouState.val == 0?
	if (FCL_VAL == 0)
0918  5237      	MOVF FCM_getTro_00042_1_FCL_VAL, F
091A  E124      	BNZ	label15
0964            label15
0982            label18

	{
		//Calcul
		//Calcul:
		//  getTrouState.Return = 0
		FCR_RETVAL = 0;
091C  6A39      	CLRF FCM_getTro_00042_1_FCR_RETVAL

		

		//Lire ADC2
		//Appel de la Routine Composant: getTrouState.val=ADC(2)::Lire_comme_Octet
		FCL_VAL = FCD_ADC2_ReadAsByte();
091E  EC85F004  	CALL FCD_ADC2_R_00046
0922  503A      	MOVF CompTempVarRet2290, W
0924  6E37      	MOVWF FCM_getTro_00042_1_FCL_VAL



		//Décision
		//Décision: getTrouState.val >= getTrouState.trig?
		if (FCL_VAL >= FCL_TRIG)
0926  5037      	MOVF FCM_getTro_00042_1_FCL_VAL, W
0928  6438      	CPFSGT FCM_getTro_00042_1_FCL_TRIG
092A  D001      	BRA	label9
092C  D003      	BRA	label10
092E            label9
0934            label10
096E  D005      	BRA	label17

		{
			//Calcul
			//Calcul:
			//  getTrouState.Return = true
			FCR_RETVAL = FCV_TRUE;
092E  5032      	MOVF gbl_FCV_TRUE, W
0930  6E39      	MOVWF FCM_getTro_00042_1_FCR_RETVAL

			

		} else {
0932  D002      	BRA	label11
0938            label11

			//Calcul
			//Calcul:
			//  getTrouState.Return = false
			FCR_RETVAL = FCV_FALSE;
0934  5033      	MOVF gbl_FCV_FALSE, W
0936  6E39      	MOVWF FCM_getTro_00042_1_FCR_RETVAL

			

		}


		//Calcul
		//Calcul:
		//  getTrouState.Return = getTrouState.Return << 1
		FCR_RETVAL = FCR_RETVAL << 1;
0938  5239      	MOVF FCM_getTro_00042_1_FCR_RETVAL, F
093A  90D8      	BCF STATUS,C
093C  3639      	RLCF FCM_getTro_00042_1_FCR_RETVAL, F

		

		//Lire ADC2
		//Appel de la Routine Composant: getTrouState.val=ADC(3)::Lire_comme_Octet
		FCL_VAL = FCD_ADC3_ReadAsByte();
093E  EC80F004  	CALL FCD_ADC3_R_00047
0942  503A      	MOVF CompTempVarRet2291, W
0944  6E37      	MOVWF FCM_getTro_00042_1_FCL_VAL



		//Décision
		//Décision: getTrouState.val >= getTrouState.trig?
		if (FCL_VAL >= FCL_TRIG)
0946  5037      	MOVF FCM_getTro_00042_1_FCL_VAL, W
0948  6438      	CPFSGT FCM_getTro_00042_1_FCL_TRIG
094A  D001      	BRA	label12
094C  D004      	BRA	label13
094E            label12
0956            label13

		{
			//Calcul
			//Calcul:
			//  getTrouState.Return = getTrouState.Return | true
			FCR_RETVAL = FCR_RETVAL | FCV_TRUE;
094E  5032      	MOVF gbl_FCV_TRUE, W
0950  1039      	IORWF FCM_getTro_00042_1_FCR_RETVAL, W
0952  6E39      	MOVWF FCM_getTro_00042_1_FCR_RETVAL

			

		} else {
0954  D003      	BRA	label14
095C            label14

			//Calcul
			//Calcul:
			//  getTrouState.Return = getTrouState.Return | false
			FCR_RETVAL = FCR_RETVAL | FCV_FALSE;
0956  5033      	MOVF gbl_FCV_FALSE, W
0958  1039      	IORWF FCM_getTro_00042_1_FCR_RETVAL, W
095A  6E39      	MOVWF FCM_getTro_00042_1_FCR_RETVAL

			

		}


		//Calcul
		//Calcul:
		//  getTrouState.Return = getTrouState.Return >> 1
		FCR_RETVAL = FCR_RETVAL >> 1;
095C  5239      	MOVF FCM_getTro_00042_1_FCR_RETVAL, F
095E  90D8      	BCF STATUS,C
0960  3239      	RRCF FCM_getTro_00042_1_FCR_RETVAL, F

		

	} else {
0962  D018      	BRA	label21

		//Multi-Décision
		//Multi-Décision: getTrouState.nb?
		switch (FCL_NB)

		{
			case 1:
0964  0436      	DECF FCM_getTro_00042_arg_FCL_NB, W
0966  E004      	BZ	label16
0970            label16

			{
				//Lire ADC2
				//Appel de la Routine Composant: getTrouState.val=ADC(2)::Lire_comme_Octet
				FCL_VAL = FCD_ADC2_ReadAsByte();
0970  EC85F004  	CALL FCD_ADC2_R_00046
0974  503A      	MOVF CompTempVarRet2290, W
0976  6E37      	MOVWF FCM_getTro_00042_1_FCL_VAL



				break;
0978  D004      	BRA	label18

			}

			case 2:
0968  0E02      	MOVLW 0x02
096A  6236      	CPFSEQ FCM_getTro_00042_arg_FCL_NB
096C  D00A      	BRA	label18
097A            label17

			{
				//Lire ADC3
				//Appel de la Routine Composant: getTrouState.val=ADC(3)::Lire_comme_Octet
				FCL_VAL = FCD_ADC3_ReadAsByte();
097A  EC80F004  	CALL FCD_ADC3_R_00047
097E  503A      	MOVF CompTempVarRet2291, W
0980  6E37      	MOVWF FCM_getTro_00042_1_FCL_VAL



				break;

			}

		}


		//Décision
		//Décision: getTrouState.val >= getTrouState.trig?
		if (FCL_VAL >= FCL_TRIG)
0982  5037      	MOVF FCM_getTro_00042_1_FCL_VAL, W
0984  6438      	CPFSGT FCM_getTro_00042_1_FCL_TRIG
0986  D001      	BRA	label19
0988  D003      	BRA	label20
098A            label19
0990            label20

		{
			//Calcul
			//Calcul:
			//  getTrouState.Return = true
			FCR_RETVAL = FCV_TRUE;
098A  5032      	MOVF gbl_FCV_TRUE, W
098C  6E39      	MOVWF FCM_getTro_00042_1_FCR_RETVAL

			

		} else {
098E  D002      	BRA	label21
0994            label21

			//Calcul
			//Calcul:
			//  getTrouState.Return = false
			FCR_RETVAL = FCV_FALSE;
0990  5033      	MOVF gbl_FCV_FALSE, W
0992  6E39      	MOVWF FCM_getTro_00042_1_FCR_RETVAL

			

		}


	}


	return (FCR_RETVAL);
0994  5039      	MOVF FCM_getTro_00042_1_FCR_RETVAL, W
0996  6E3A      	MOVWF CompTempVarRet2201

}
0998  0012      	RETURN


//Implémentations supplémentaires


void main()

{
	
	//Initialisation
	adcon1 = 0x0F;
09F6  0E0F      	MOVLW 0x0F
09F8  6EC1      	MOVWF gbl_adcon1

	ucfg = 0x08;
09FA  0E08      	MOVLW 0x08
09FC  6E6F      	MOVWF gbl_ucfg

cr_bit(pie2, USBIE);
09FE  9AA0      	BCF gbl_pie2,5



	//Code d'initialisation d'Interruption
	


	//Calcul
	//Calcul:
	//  true = 1
	//  false = 0
	//  stop = 0
	//  avant = 1
	//  arriere = 2
	//  droit = 0
	//  left = -90
	//  right = 90
	FCV_TRUE = 1;
0A00  0E01      	MOVLW 0x01
0A02  6E32      	MOVWF gbl_FCV_TRUE

	FCV_FALSE = 0;
0A04  6A33      	CLRF gbl_FCV_FALSE

	FCV_STOP = 0;
0A06  6A2C      	CLRF gbl_FCV_STOP

	FCV_AVANT = 1;
0A08  0E01      	MOVLW 0x01
0A0A  6E31      	MOVWF gbl_FCV_AVANT

	FCV_ARRIERE = 2;
0A0C  0E02      	MOVLW 0x02
0A0E  6E30      	MOVWF gbl_FCV_ARRIERE

	FCV_DROIT = 0;
0A10  6A2F      	CLRF gbl_FCV_DROIT

	FCV_LEFT = -90;
0A12  0EA6      	MOVLW 0xA6
0A14  6E2D      	MOVWF gbl_FCV_LEFT

	FCV_RIGHT = 90;
0A16  0E5A      	MOVLW 0x5A
0A18  6E2E      	MOVWF gbl_FCV_RIGHT

	

	//Décision
	//Décision: true?
	if (FCV_TRUE)
0A1A  5232      	MOVF gbl_FCV_TRUE, F
0A1C  E009      	BZ	label30
0A30            label30

	{
		//Appel de la Routine Composant
		//Appel de la Routine Composant: Stepper(0)::EnableMotor
		FCD_Stepper0_EnableMotor();
0A1E  ECCDF004  	CALL FCD_Steppe_0005C



		//Boucle
		//Boucle: Tant que 1
		while (1)
0A22            label29
0A2E  D7F9      	BRA	label29

		{
			//Appel de la Routine Composant
			//Appel de la Routine Composant: Stepper(0)::IncrementStep
			FCD_Stepper0_IncrementStep();
0A22  ECD8F004  	CALL FCD_Steppe_0005A



			//Pause
			//Pause: 50 ms
			delay_ms(50);
0A26  0E32      	MOVLW 0x32
0A28  6E36      	MOVWF delay_ms_00000_arg_del
0A2A  EC06F004  	CALL delay_ms_00000



		}


	} else {
		//Boucle
		//Boucle: Tant que 1
		while (1)
0A36  D7FC      	BRA	label30

		{
			//Appel d'une Macro
			//Appel d'une Macro: getTrouState(0)
			FCM_getTrouState(0);
0A30  6A36      	CLRF FCM_getTro_00042_arg_FCL_NB
0A32  EC8AF004  	CALL FCM_getTro_00042



		}


	}


	//Appel d'une Macro
	//Appel d'une Macro: initLed
	FCM_initLed();



	//Boucle
	//Boucle: Tant que 1
	while (1)
	{
		//Appel d'une Macro
		//Appel d'une Macro: battLevelOk=getBat
		FCV_BATTLEVELOK = FCM_getBat();



		//Appel d'une Macro
		//Appel d'une Macro: showLevel(battLevelOk)
		FCM_showLevel(FCV_BATTLEVELOK);



		//Appel d'une Macro
		//Appel d'une Macro: battLevelOk=isBattLevelOK(127)
		FCV_BATTLEVELOK = FCM_isBattLevelOK(127);



		//Décision
		//Décision: battLevelOk?
		if (FCV_BATTLEVELOK)
		{
			//Commentaire:
			//C'est parti !!!


			//Appel d'une Macro
			//Appel d'une Macro: move(255, avant, droit)
			FCM_move(255, FCV_AVANT, FCV_DROIT);



			//Appel d'une Macro
			//Appel d'une Macro: isTrou=getTrou(1000)
			FCV_ISTROU = FCM_getTrou(1000);



			//Décision
			//Décision: isTrou?
			if (FCV_ISTROU)
			{
				//Commentaire:
				//Alignement


				//Appel d'une Macro
				//Appel d'une Macro: align
				FCM_align();



				//Commentaire:
				//Test trou !
				//(Longueur)


				//Commentaire:
				//On recule de 5cm : 
				//Pendant 1s a 0.035% de la vitesse max
				//0.035% => 9 / 255


				//Appel d'une Macro
				//Appel d'une Macro: move(9, arriere, droit)
				FCM_move(9, FCV_ARRIERE, FCV_DROIT);



				//Pause
				//Pause: 1 s
				delay_s(1);



				//Appel d'une Macro
				//Appel d'une Macro: move(stop, avant, droit)
				FCM_move(FCV_STOP, FCV_AVANT, FCV_DROIT);



				//Commentaire:
				//Pose verrins


				//Appel d'une Macro
				//Appel d'une Macro: verrin(false)
				FCM_verrin(FCV_FALSE);



				//Commentaire:
				//Début pose pont


				//Sortie
				//Sortie: 0 -> C6
				trisc = trisc & 0xbf;

				if (0)
					portc = (portc & 0xbf) | 0x40;
				else
					portc = portc & 0xbf;



				//Sortie
				//Sortie: 1 -> E2
				trise = trise & 0xfb;

				if (1)
					porte = (porte & 0xfb) | 0x04;

				else
					porte = porte & 0xfb;


				//Tempo demi pose pont
				//Pause: 15 s
				delay_s(15);



				//Commentaire:
				//Début dépliage pont


				//Sortie
				//Sortie: 0 -> E0
				trise = trise & 0xfe;

				if (0)
					porte = (porte & 0xfe) | 0x01;
				else
					porte = porte & 0xfe;



				//Sortie
				//Sortie: 1 -> E1
				trise = trise & 0xfd;

				if (1)
					porte = (porte & 0xfd) | 0x02;

				else
					porte = porte & 0xfd;


				//Commentaire:
				//Attente des FDC


				//Calcul
				//Calcul:
				//  i = 0
				FCV_I = 0;

				

				//Boucle
				//Boucle: Tant que i != 0b11
				while (FCV_I != 3)
				{
					//Entrée
					//Entrée: PORTB -> pB
					trisb = trisb | 0xff;

					FCV_PB = portb;



					//Décision
					//Décision: (pB & 0b100000) != 0?
					if ((FCV_PB & 32) != 0)
					{
						//Calcul
						//Calcul:
						//  i = i | 0b01
						FCV_I = FCV_I | 1;

						

						//Sortie
						//Sortie: 0 -> E1
						trise = trise & 0xfd;

						if (0)
							porte = (porte & 0xfd) | 0x02;
						else
							porte = porte & 0xfd;



					}


					//Décision
					//Décision: (pB & 0b10000000) != 0?
					if ((FCV_PB & 128) != 0)
					{
						//Calcul
						//Calcul:
						//  i = i | 0b10
						FCV_I = FCV_I | 2;

						

						//Sortie
						//Sortie: 0 -> E2
						trise = trise & 0xfb;

						if (0)
							porte = (porte & 0xfb) | 0x04;
						else
							porte = porte & 0xfb;



					}


				}


				//Commentaire:
				//Remonté verrins


				//Appel d'une Macro
				//Appel d'une Macro: verrin(true)
				FCM_verrin(FCV_TRUE);



				//Commentaire:
				//Recule (enlever la pince)


				//Appel d'une Macro
				//Appel d'une Macro: move(63, arriere, droit)
				FCM_move(63, FCV_ARRIERE, FCV_DROIT);



				//Pause
				//Pause: 3 s
				delay_s(3);



				//Commentaire:
				//Monter la pince


				//Sortie
				//Sortie: 0 -> C6
				trisc = trisc & 0xbf;

				if (0)
					portc = (portc & 0xbf) | 0x40;
				else
					portc = portc & 0xbf;



				//Sortie
				//Sortie: 1 -> E2
				trise = trise & 0xfb;

				if (1)
					porte = (porte & 0xfb) | 0x04;

				else
					porte = porte & 0xfb;


				//Pause
				//Pause: 3 s
				delay_s(3);



				//Sortie
				//Sortie: 0 -> E2
				trise = trise & 0xfb;

				if (0)
					porte = (porte & 0xfb) | 0x04;
				else
					porte = porte & 0xfb;



				//Commentaire:
				//Passage sur le pont
				//5km/h
				//5000m/h
				//1.388m/s
				//=> 1.5m
				//==> 1s à 100%


				//Appel d'une Macro
				//Appel d'une Macro: move(25, avant, droit)
				FCM_move(25, FCV_AVANT, FCV_DROIT);



				//Pause
				//Pause: 10 s
				delay_s(10);



				//Commentaire:
				//Demi - tour


				//Appel d'une Macro
				//Appel d'une Macro: move(25, avant, -90)
				FCM_move(25, FCV_AVANT, -90);



				//Pause
				//Pause: 10 s
				delay_s(10);



				//Commentaire:
				//Baisser la pince


				//Sortie
				//Sortie: 1 -> C6
				trisc = trisc & 0xbf;

				if (1)
					portc = (portc & 0xbf) | 0x40;

				else
					portc = portc & 0xbf;


				//Sortie
				//Sortie: 0 -> E2
				trise = trise & 0xfb;

				if (0)
					porte = (porte & 0xfb) | 0x04;
				else
					porte = porte & 0xfb;



				//Boucle
				//Boucle: Tant que pB
				while (!(FCV_PB))
				{
					//Entrée
					//Entrée: B7 -> pB
					trisb = trisb | 0x80;

					FCV_PB = ((portb & 0x80) == 0x80);



				}


				//Sortie
				//Sortie: 0 -> C6
				trisc = trisc & 0xbf;

				if (0)
					portc = (portc & 0xbf) | 0x40;
				else
					portc = portc & 0xbf;



				//Commentaire:
				//Prise pont


				//Appel d'une Macro
				//Appel d'une Macro: move(127, avant, droit)
				FCM_move(127, FCV_AVANT, FCV_DROIT);



				//Pause
				//Pause: 5 s
				delay_s(5);



				//Commentaire:
				//Début prise pont


				//Sortie
				//Sortie: 1 -> C6
				trisc = trisc & 0xbf;

				if (1)
					portc = (portc & 0xbf) | 0x40;

				else
					portc = portc & 0xbf;


				//Sortie
				//Sortie: 0 -> E2
				trise = trise & 0xfb;

				if (0)
					porte = (porte & 0xfb) | 0x04;
				else
					porte = porte & 0xfb;



				//Tempo demi pose pont
				//Pause: 15 s
				delay_s(15);



				//Commentaire:
				//Début pliage pont


				//Sortie
				//Sortie: 1 -> E0
				trise = trise & 0xfe;

				if (1)
					porte = (porte & 0xfe) | 0x01;

				else
					porte = porte & 0xfe;


				//Sortie
				//Sortie: 0 -> E1
				trise = trise & 0xfd;

				if (0)
					porte = (porte & 0xfd) | 0x02;
				else
					porte = porte & 0xfd;



				//Commentaire:
				//Attente des FDC


				//Calcul
				//Calcul:
				//  i = 0
				FCV_I = 0;

				

				//Boucle
				//Boucle: Tant que i != 0b11
				while (FCV_I != 3)
				{
					//Entrée
					//Entrée: PORTB -> pB
					trisb = trisb | 0xff;

					FCV_PB = portb;



					//Décision
					//Décision: (pB & 0b10000) != 0?
					if ((FCV_PB & 16) != 0)
					{
						//Calcul
						//Calcul:
						//  i = i | 0b01
						FCV_I = FCV_I | 1;

						

						//Sortie
						//Sortie: 0 -> E0
						trise = trise & 0xfe;

						if (0)
							porte = (porte & 0xfe) | 0x01;
						else
							porte = porte & 0xfe;



					}


					//Décision
					//Décision: (pB & 0b1000000) != 0?
					if ((FCV_PB & 64) != 0)
					{
						//Calcul
						//Calcul:
						//  i = i | 0b10
						FCV_I = FCV_I | 2;

						

						//Sortie
						//Sortie: 0 -> C6
						trisc = trisc & 0xbf;

						if (0)
							portc = (portc & 0xbf) | 0x40;
						else
							portc = portc & 0xbf;



					}


				}


				//Commentaire:
				//Demi - tour


				//Appel d'une Macro
				//Appel d'une Macro: move(25, avant, -90)
				FCM_move(25, FCV_AVANT, -90);



				//Pause
				//Pause: 10 s
				delay_s(10);



			}


		} else {
			//Commentaire:
			//Nope :(


			//Appel d'une Macro
			//Appel d'une Macro: move(stop, 0, 0)
			FCM_move(FCV_STOP, 0, 0);



			//Pause
			//Pause: 500 ms
			delay_ms(255);

			delay_ms(245);



			//Appel d'une Macro
			//Appel d'une Macro: showLevel(0)
			FCM_showLevel(0);



			//Pause
			//Pause: 500 ms
			delay_ms(255);

			delay_ms(245);



		}


	}


	mainendloop: goto mainendloop;
}


void MX_INTERRUPT_MACRO(void)

{
}
0AA6  CFEAF001  	MOVFF FSR0H,  Int1Context
0AAA  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
0AAE  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
0AB2  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
0AB6  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
0ABA  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
0ABE  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
0AC2  C001FFEA  	MOVFF Int1Context,  FSR0H
0AC6  0011      	RETFIE 1





////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0800  EF1CF005  	GOTO	_startup

0808  EF53F005  	GOTO	interrupt
080C            delay_ms_00000
080C            ; { delay_ms ; function begin
080C  5236      	MOVF delay_ms_00000_arg_del, F
080E  0000      	NOP
0810  E101      	BNZ	label1
0812  0012      	RETURN
0814            label1
0814  0EFF      	MOVLW 0xFF
0816            label2
0816  0000      	NOP
0818  0000      	NOP
081A  0000      	NOP
081C  0000      	NOP
081E  0000      	NOP
0820  0000      	NOP
0822  0000      	NOP
0824  0000      	NOP
0826  0000      	NOP
0828  0000      	NOP
082A  0000      	NOP
082C  0000      	NOP
082E  0000      	NOP
0830  0000      	NOP
0832  0000      	NOP
0834  0000      	NOP
0836  0000      	NOP
0838  0000      	NOP
083A  0000      	NOP
083C  0000      	NOP
083E  0000      	NOP
0840  0000      	NOP
0842  0000      	NOP
0844  0000      	NOP
0846  0000      	NOP
0848  0000      	NOP
084A  0000      	NOP
084C  0000      	NOP
084E  0000      	NOP
0850  0000      	NOP
0852  0000      	NOP
0854  0000      	NOP
0856  0000      	NOP
0858  0000      	NOP
085A  0000      	NOP
085C  0000      	NOP
085E  0000      	NOP
0860  0000      	NOP
0862  0000      	NOP
0864  0000      	NOP
0866  0000      	NOP
0868  0000      	NOP
086A  0000      	NOP
086C  0FFF      	ADDLW 0xFF
086E  A4D8      	BTFSS STATUS,Z
0870  D7D2      	BRA	label2
0872  0000      	NOP
0874  0000      	NOP
0876  0000      	NOP
0878  0000      	NOP
087A  0000      	NOP
087C  0000      	NOP
087E  0000      	NOP
0880  0000      	NOP
0882  0000      	NOP
0884  0000      	NOP
0886  0000      	NOP
0888  0000      	NOP
088A  2E36      	DECFSZ delay_ms_00000_arg_del, F
088C  D7C3      	BRA	label1
088E  0012      	RETURN
0890            ; } delay_ms function end


0A38            _startup
0A38  0ED5      	MOVLW 0xD5
0A3A  6E0D      	MOVWF gbl_16_LSR
0A3C  0EC4      	MOVLW 0xC4
0A3E  6E0E      	MOVWF gbl_16_LSR+D'1'
0A40  0EBB      	MOVLW 0xBB
0A42  6E0F      	MOVWF gbl_16_LSR+D'2'
0A44  0EDC      	MOVLW 0xDC
0A46  6E10      	MOVWF gbl_16_LSR+D'3'
0A48  6A11      	CLRF gbl_17_gbl_aSig
0A4A  6A12      	CLRF gbl_17_gbl_aSig+D'1'
0A4C  6A13      	CLRF gbl_17_gbl_aSig+D'2'
0A4E  6A14      	CLRF gbl_17_gbl_aSig+D'3'
0A50  6A15      	CLRF gbl_17_gbl_bSig
0A52  6A16      	CLRF gbl_17_gbl_bSig+D'1'
0A54  6A17      	CLRF gbl_17_gbl_bSig+D'2'
0A56  6A18      	CLRF gbl_17_gbl_bSig+D'3'
0A58  6A19      	CLRF gbl_17_gbl_zSig
0A5A  6A1A      	CLRF gbl_17_gbl_zSig+D'1'
0A5C  6A1B      	CLRF gbl_17_gbl_zSig+D'2'
0A5E  6A1C      	CLRF gbl_17_gbl_zSig+D'3'
0A60  6A26      	CLRF gbl_17_gbl_aExp
0A62  6A27      	CLRF gbl_17_gbl_bExp
0A64  6A21      	CLRF gbl_17_gbl_zExp
0A66  6A22      	CLRF gbl_17_gbl_zExp+D'1'
0A68  6A28      	CLRF gbl_17_gbl_aSign
0A6A  6A29      	CLRF gbl_17_gbl_bSign
0A6C  6A2A      	CLRF gbl_17_gbl_zSign
0A6E  6A2B      	CLRF gbl_17_gbl_zSigZero
0A70  6A1D      	CLRF gbl_17_gbl_ret
0A72  6A1E      	CLRF gbl_17_gbl_ret+D'1'
0A74  6A1F      	CLRF gbl_17_gbl_ret+D'2'
0A76  6A20      	CLRF gbl_17_gbl_ret+D'3'
0A78  6A24      	CLRF gbl_float_rounding_mode
0A7A  6A25      	CLRF gbl_float_exception_flags
0A7C  6A23      	CLRF gbl_float_detect_tininess

0AA2  EFFBF004  	GOTO	main

300000  0E20      	DW 0x0E20
300002  1E3E      	DW 0x1E3E
300004  8100      	DW 0x8100
300006  0081      	DW 0x0081
300008  800F      	DW 0x800F
30000A  A00F      	DW 0xA00F
30000C  000F      	DW 0x000F
